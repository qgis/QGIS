/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/geometry/qgsgeometry.h                                      *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
 ************************************************************************/









typedef QVector<QgsPointXY> QgsPolylineXY;

typedef QgsPointSequence QgsPolyline;

typedef QVector<QVector<QgsPointXY>> QgsPolygonXY;

typedef QVector<QgsPointXY> QgsMultiPointXY;

typedef QVector<QVector<QgsPointXY>> QgsMultiPolylineXY;

typedef QVector<QVector<QVector<QgsPointXY>>> QgsMultiPolygonXY;




class QgsGeometryParameters
{
%Docstring(signature="appended")
Encapsulates parameters under which a geometry operation is performed.

.. versionadded:: 3.28
%End

%TypeHeaderCode
#include "qgsgeometry.h"
%End
  public:

    double gridSize() const;
%Docstring
Returns the grid size which will be used to snap vertices of a geometry.

This parameter is used to control the grid size (or precision) for GEOS geometry operations. Output
geometry result vertices will be computed on that same precision grid.

A value of -1 indicates that no precision reduction will be applied.

.. seealso:: :py:func:`setGridSize`
%End

    void setGridSize( double size );
%Docstring
Sets the grid ``size`` which will be used to snap vertices of a geometry.

This parameter is used to control the grid size (or precision) for GEOS geometry operations. Output
geometry result vertices will be computed on that same precision grid.

A value of -1 indicates that no precision reduction will be applied.

.. seealso:: :py:func:`gridSize`
%End

};

class QgsGeometry
{
%Docstring(signature="appended")
A geometry is the spatial representation of a feature.

:py:class:`QgsGeometry` acts as a generic container for geometry objects. :py:class:`QgsGeometry` objects are implicitly shared,
so making copies of geometries is inexpensive. The geometry container class can also be stored inside
a QVariant object.

The actual geometry representation is stored as a :py:class:`QgsAbstractGeometry` within the container, and
can be accessed via the :py:func:`~QgsGeometryParameters.get` method or set using the :py:func:`~QgsGeometryParameters.set` method. This gives access to the underlying
raw geometry primitive, such as the point, line, polygon, curve or other geometry subclasses.

.. note::

   :py:class:`QgsGeometry` objects are inherently Cartesian/planar geometries. They have no concept of geodesy, and none
   of the methods or properties exposed from the :py:class:`QgsGeometry` API (or :py:class:`QgsAbstractGeometry` subclasses) utilize
   geodesic calculations. Accordingly, properties like :py:func:`~QgsGeometryParameters.length` and :py:func:`~QgsGeometryParameters.area` or spatial operations like :py:func:`~QgsGeometryParameters.buffer`
   are always calculated using strictly Cartesian mathematics. In contrast, the :py:class:`QgsDistanceArea` class exposes
   methods for working with geodesic calculations and spatial operations on geometries,
   and should be used whenever calculations which account for the curvature of the Earth (or any other celestial body)
   are required.
%End

%TypeHeaderCode
#include "qgsgeometry.h"
%End
  public:
    static const QMetaObject staticMetaObject;

  public:

    QgsGeometry() /HoldGIL/;
%Docstring
Constructor
%End

    QgsGeometry( const QgsGeometry & );
%Docstring
Copy constructor will prompt a deep copy of the object
%End


    explicit QgsGeometry( QgsAbstractGeometry *geom /Transfer/ );
%Docstring
Creates a geometry from an abstract geometry object. Ownership of
geom is transferred.
%End


    virtual ~QgsGeometry();

    const QgsAbstractGeometry *constGet() const /HoldGIL/;
%Docstring
Returns a non-modifiable (const) reference to the underlying abstract geometry primitive.

This is much faster then calling the non-const :py:func:`~QgsGeometry.get` method.

.. note::

   In QGIS 2.x this method was named :py:func:`~QgsGeometry.geometry`.

.. seealso:: :py:func:`set`

.. seealso:: :py:func:`get`
%End

    QgsAbstractGeometry *get();
%Docstring
Returns a modifiable (non-const) reference to the underlying abstract geometry primitive.

This method can be slow to call, as it may trigger a detachment of the geometry
and a deep copy. Where possible, use :py:func:`~QgsGeometry.constGet` instead.

.. note::

   In QGIS 2.x this method was named :py:func:`~QgsGeometry.geometry`.

.. seealso:: :py:func:`constGet`

.. seealso:: :py:func:`set`
%End

    void set( QgsAbstractGeometry *geometry /Transfer/ ) /Deprecated/;
%Docstring
Sets the underlying geometry store. Ownership of geometry is transferred.

.. note::

   In QGIS 2.x this method was named :py:func:`~QgsGeometry.setGeometry`.

.. note::

   This method is deprecated for usage in Python and will be removed from Python bindings with QGIS 4.
   Using this method will confuse Python's memory management and type information system.
   Better create a new QgsGeometry object instead.

.. seealso:: :py:func:`get`

.. seealso:: :py:func:`constGet`
%End

    bool isNull() const /HoldGIL/;
%Docstring
Returns ``True`` if the geometry is null (ie, contains no underlying geometry
accessible via :py:func:`~QgsGeometry.get` or :py:func:`~QgsGeometry.constGet` ).

.. seealso:: :py:func:`get`

.. seealso:: :py:func:`constGet`

.. seealso:: :py:func:`isEmpty`
%End

    static QgsGeometry fromWkt( const QString &wkt );
%Docstring
Creates a new geometry from a WKT string
%End
    static QgsGeometry fromPointXY( const QgsPointXY &point ) /HoldGIL/;
%Docstring
Creates a new geometry from a :py:class:`QgsPointXY` object
%End

    static QgsGeometry fromPoint( const QgsPoint &point ) /HoldGIL/;
%Docstring
Creates a new geometry from a :py:class:`QgsPoint` object.

.. versionadded:: 3.34
%End

    static QgsGeometry fromMultiPointXY( const QgsMultiPointXY &multipoint );
%Docstring
Creates a new geometry from a :py:class:`QgsMultiPointXY` object
%End

    static QgsGeometry fromPolylineXY( const QgsPolylineXY &polyline );
%Docstring
Creates a new LineString geometry from a list of :py:class:`QgsPointXY` points.

Using :py:func:`~QgsGeometry.fromPolyline` is preferred, as :py:func:`~QgsGeometry.fromPolyline` is more efficient
and will respect any Z or M dimensions present in the input points.

.. note::

   In QGIS 2.x this method was available as :py:func:`~QgsGeometry.fromPolyline`.

.. seealso:: :py:func:`fromPolyline`
%End

    static QgsGeometry fromPolyline( const QgsPolyline &polyline );
%Docstring
Creates a new LineString geometry from a list of :py:class:`QgsPoint` points.

This method will respect any Z or M dimensions present in the input points.
E.g. if input points are PointZ type, the resultant linestring will be
a LineStringZ type.
%End

    static QgsGeometry fromMultiPolylineXY( const QgsMultiPolylineXY &multiline );
%Docstring
Creates a new geometry from a :py:class:`QgsMultiPolylineXY` object.
%End


    static QgsGeometry fromPolygonXY( const QgsPolygonXY &polygon );
%Docstring
Creates a new polygon geometry from a list of lists of :py:class:`QgsPointXY`.

The first list of :py:class:`QgsPointXY` objects specifies the exterior ring of the polygon, and the remaining
lists specify any interior rings.

Example
-------

.. code-block:: python

       # Create a polygon geometry with a single exterior ring (a triangle)
       polygon = QgsGeometry.fromPolygonXY([[QgsPointXY(1, 2), QgsPointXY(5, 2), QgsPointXY(5, 10), QgsPointXY(1, 2)]]))

       # Create a donut shaped polygon geometry with an interior ring
       polygon = QgsGeometry.fromPolygonXY([[QgsPointXY(1, 2), QgsPointXY(5, 2), QgsPointXY(5, 10), QgsPointXY(1, 10), QgsPointXY(1, 2)],
                                            [QgsPointXY(3, 4), QgsPointXY(4, 4), QgsPointXY(4, 6), QgsPointXY(3, 6), QgsPointXY(3, 4)]])
%End

    static QgsGeometry fromMultiPolygonXY( const QgsMultiPolygonXY &multipoly );
%Docstring
Creates a new geometry from a :py:class:`QgsMultiPolygonXY`.
%End

    static QgsGeometry fromRect( const QgsRectangle &rect ) /HoldGIL/;
%Docstring
Creates a new geometry from a :py:class:`QgsRectangle`
%End

    static QgsGeometry fromBox3D( const QgsBox3D &box ) /HoldGIL/;
%Docstring
Creates a new geometry from a :py:class:`QgsBox3D` object

.. versionadded:: 3.34
%End


    static QgsGeometry collectGeometry( const QVector<QgsGeometry> &geometries );
%Docstring
Creates a new multipart geometry from a list of QgsGeometry objects
%End

    static QgsGeometry createWedgeBuffer( const QgsPoint &center, double azimuth, double angularWidth,
                                          double outerRadius, double innerRadius = 0 );
%Docstring
Creates a wedge shaped buffer from a ``center`` point.

The ``azimuth`` gives the angle (in degrees) for the middle of the wedge to point.
The buffer width (in degrees) is specified by the ``angularWidth`` parameter. Note that the
wedge will extend to half of the ``angularWidth`` either side of the ``azimuth`` direction.

The outer radius of the buffer is specified via ``outerRadius``, and optionally an
``innerRadius`` can also be specified.

The returned geometry will be a CurvePolygon geometry containing circular strings. It may
need to be segmentized to convert to a standard Polygon geometry.

.. versionadded:: 3.2
%End


    void fromWkb( const QByteArray &wkb );
%Docstring
Set the geometry, feeding in the buffer containing OGC Well-Known Binary
%End

    Qgis::WkbType wkbType() const /HoldGIL/;
%Docstring
Returns type of the geometry as a WKB type (point / linestring / polygon etc.)

.. seealso:: :py:func:`type`
%End

    Qgis::GeometryType type() const /HoldGIL/;
%Docstring
Returns type of the geometry as a :py:class:`Qgis`.GeometryType

.. seealso:: :py:func:`wkbType`
%End

    bool isEmpty() const /HoldGIL/;
%Docstring
Returns ``True`` if the geometry is empty (eg a linestring with no vertices,
or a collection with no geometries). A null geometry will always
return ``True`` for :py:func:`~QgsGeometry.isEmpty`.

.. seealso:: :py:func:`isNull`
%End

    bool isMultipart() const /HoldGIL/;
%Docstring
Returns ``True`` if WKB of the geometry is of WKBMulti* type
%End

    bool equals( const QgsGeometry &geometry ) const;
%Docstring
Test if this geometry is exactly equal to another ``geometry``.

This is a strict equality check, where the underlying geometries must
have exactly the same type, component vertices and vertex order.

Calling this method is dramatically faster than the topological
equality test performed by :py:func:`~QgsGeometry.isGeosEqual`.

.. note::

   Comparing two null geometries will return ``False``.

.. seealso:: :py:func:`isGeosEqual`
%End

    bool isGeosEqual( const QgsGeometry & ) const;
%Docstring
Compares the geometry with another geometry using GEOS.

This method performs a slow, topological check, where geometries
are considered equal if all of the their component edges overlap. E.g.
lines with the same vertex locations but opposite direction will be
considered equal by this method.

Consider using the much faster, stricter equality test performed
by :py:func:`~QgsGeometry.equals` instead.

.. note::

   Comparing two null geometries will return ``False``.

.. seealso:: :py:func:`equals`
%End

    bool isGeosValid( Qgis::GeometryValidityFlags flags = Qgis::GeometryValidityFlags() ) const;
%Docstring
Checks validity of the geometry using GEOS.

The ``flags`` parameter indicates optional flags which control the type of validity checking performed.
%End

    bool isSimple() const;
%Docstring
Determines whether the geometry is simple (according to OGC definition),
i.e. it has no anomalous geometric points, such as self-intersection or self-tangency.
Uses GEOS library for the test.

.. note::

   This is useful mainly for linestrings and linear rings. Polygons are simple by definition,
   for checking anomalies in polygon geometries one can use :py:func:`~QgsGeometry.isGeosValid`.
%End

    bool isAxisParallelRectangle( double maximumDeviation, bool simpleRectanglesOnly = false ) const;
%Docstring
Returns ``True`` if the geometry is a polygon that is almost an axis-parallel rectangle.

The ``maximumDeviation`` argument specifes the maximum angle (in degrees) that the polygon edges
are allowed to deviate from axis parallel lines.

By default the check will permit polygons with more than 4 edges, so long as the overall shape of
the polygon is an axis-parallel rectangle (i.e. it is tolerant to rectangles with additional vertices
added along the rectangle sides). If ``simpleRectanglesOnly`` is set to ``True`` then the method will
only return ``True`` if the geometry is a simple rectangle consisting of 4 edges.

.. versionadded:: 3.20
%End

    double area() const;
%Docstring
Returns the planar, 2-dimensional area of the geometry.

.. warning::

   QgsGeometry objects are inherently Cartesian/planar geometries, and the area
   returned by this method is calculated using strictly Cartesian mathematics. In contrast,
   the :py:class:`QgsDistanceArea` class exposes methods for calculating the areas of geometries using
   geodesic calculations which account for the curvature of the Earth (or any other
   celestial body).

.. seealso:: :py:func:`length`
%End

    double length() const;
%Docstring
Returns the planar, 2-dimensional length of geometry.

If the geometry is a polygon geometry then the perimeter of the polygon will be returned.

.. warning::

   QgsGeometry objects are inherently Cartesian/planar geometries, and the length
   returned by this method is calculated using strictly Cartesian mathematics. In contrast,
   the :py:class:`QgsDistanceArea` class exposes methods for calculating the lengths of geometries using
   geodesic calculations which account for the curvature of the Earth (or any other
   celestial body).

.. seealso:: :py:func:`area`
%End

    double distance( const QgsGeometry &geom ) const;
%Docstring
Returns the minimum distance between this geometry and another geometry.
Will return a negative value if either geometry is empty or null.

.. warning::

   QgsGeometry objects are inherently Cartesian/planar geometries, and the distance
   returned by this method is calculated using strictly Cartesian mathematics.
%End


    QgsVertexIterator vertices() const;
%Docstring
Returns a read-only, Java-style iterator for traversal of vertices of all the geometry, including all geometry parts and rings.

.. warning::

   The iterator returns a copy of individual vertices, and accordingly geometries cannot be
   modified using the iterator. See :py:func:`~QgsGeometry.transformVertices` for a safe method to modify vertices "in-place".

Example
-------

.. code-block:: python

       # print the x and y coordinate for each vertex in a LineString
       geometry = QgsGeometry.fromWkt( 'LineString( 0 0, 1 1, 2 2)' )
       for v in geometry.vertices():
           print(v.x(), v.y())

       # vertex iteration includes all parts and rings
       geometry = QgsGeometry.fromWkt( 'MultiPolygon((( 0 0, 0 10, 10 10, 10 0, 0 0 ),( 5 5, 5 6, 6 6, 6 5, 5 5)),((20 2, 22 2, 22 4, 20 4, 20 2)))' )
       for v in geometry.vertices():
           print(v.x(), v.y())



.. seealso:: :py:func:`parts`
%End


    QgsGeometryPartIterator parts();
%Docstring
Returns Java-style iterator for traversal of parts of the geometry. This iterator
can safely be used to modify parts of the geometry.

This method forces a detach. Use :py:func:`~QgsGeometry.constParts` to avoid the detach
if the parts are not going to be modified.

Example
-------

.. code-block:: python

       # print the WKT representation of each part in a multi-point geometry
       geometry = QgsGeometry.fromWkt( 'MultiPoint( 0 0, 1 1, 2 2)' )
       for part in geometry.parts():
           print(part.asWkt())

       # single part geometries only have one part - this loop will iterate once only
       geometry = QgsGeometry.fromWkt( 'LineString( 0 0, 10 10 )' )
       for part in geometry.parts():
           print(part.asWkt())

       # parts can be modified during the iteration
       geometry = QgsGeometry.fromWkt( 'MultiPoint( 0 0, 1 1, 2 2)' )
       for part in geometry.parts():
           part.transform(ct)

       # part iteration can also be combined with vertex iteration
       geometry = QgsGeometry.fromWkt( 'MultiPolygon((( 0 0, 0 10, 10 10, 10 0, 0 0 ),( 5 5, 5 6, 6 6, 6 5, 5 5)),((20 2, 22 2, 22 4, 20 4, 20 2)))' )
       for part in geometry.parts():
           for v in part.vertices():
               print(v.x(), v.y())

.. seealso:: :py:func:`constParts`

.. seealso:: :py:func:`vertices`

.. versionadded:: 3.6
%End

    QgsGeometryConstPartIterator constParts() const;
%Docstring
Returns Java-style iterator for traversal of parts of the geometry. This iterator
returns read-only references to parts and cannot be used to modify the parts.

Unlike :py:func:`~QgsGeometry.parts`, this method does not force a detach and is more efficient if read-only
iteration only is required.

Example
-------

.. code-block:: python

       # print the WKT representation of each part in a multi-point geometry
       geometry = QgsGeometry.fromWkt( 'MultiPoint( 0 0, 1 1, 2 2)' )
       for part in geometry.constParts():
           print(part.asWkt())

       # single part geometries only have one part - this loop will iterate once only
       geometry = QgsGeometry.fromWkt( 'LineString( 0 0, 10 10 )' )
       for part in geometry.constParts():
           print(part.asWkt())

       # part iteration can also be combined with vertex iteration
       geometry = QgsGeometry.fromWkt( 'MultiPolygon((( 0 0, 0 10, 10 10, 10 0, 0 0 ),( 5 5, 5 6, 6 6, 6 5, 5 5)),((20 2, 22 2, 22 4, 20 4, 20 2)))' )
       for part in geometry.constParts():
           for v in part.vertices():
               print(v.x(), v.y())

.. seealso:: :py:func:`parts`

.. seealso:: :py:func:`vertices`

.. versionadded:: 3.6
%End

    double hausdorffDistance( const QgsGeometry &geom ) const;
%Docstring
Returns the Hausdorff distance between this geometry and ``geom``. This is basically a measure of how similar or dissimilar 2 geometries are.

This algorithm is an approximation to the standard Hausdorff distance. This approximation is exact or close enough for a large
subset of useful cases. Examples of these are:

- computing distance between Linestrings that are roughly parallel to each other,
  and roughly equal in length. This occurs in matching linear networks.
- Testing similarity of geometries.

If the default approximate provided by this method is insufficient, use :py:func:`~QgsGeometry.hausdorffDistanceDensify` instead.

In case of error -1 will be returned.

.. seealso:: :py:func:`hausdorffDistanceDensify`
%End

    double hausdorffDistanceDensify( const QgsGeometry &geom, double densifyFraction ) const;
%Docstring
Returns the Hausdorff distance between this geometry and ``geom``. This is basically a measure of how similar or dissimilar 2 geometries are.

This function accepts a ``densifyFraction`` argument. The function performs a segment
densification before computing the discrete Hausdorff distance. The ``densifyFraction`` parameter
sets the fraction by which to densify each segment. Each segment will be split into a
number of equal-length subsegments, whose fraction of the total length is
closest to the given fraction.

This method can be used when the default approximation provided by :py:func:`~QgsGeometry.hausdorffDistance`
is not sufficient. Decreasing the ``densifyFraction`` parameter will make the
distance returned approach the true Hausdorff distance for the geometries.

In case of error -1 will be returned.

.. seealso:: :py:func:`hausdorffDistance`
%End

    double frechetDistance( const QgsGeometry &geom ) const throw( QgsNotSupportedException );
%Docstring
Returns the Fréchet distance between this geometry and ``geom``, restricted to discrete points for both geometries.

The Fréchet distance is a measure of similarity between curves that takes into account the location and ordering of the points along the curves.
Therefore it is often better than the Hausdorff distance.

In case of error -1 will be returned.

This method requires a QGIS build based on GEOS 3.7 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.6 or earlier.

.. seealso:: :py:func:`frechetDistanceDensify`

.. versionadded:: 3.20
%End

    double frechetDistanceDensify( const QgsGeometry &geom, double densifyFraction ) const throw( QgsNotSupportedException );
%Docstring
Returns the Fréchet distance between this geometry and ``geom``, restricted to discrete points for both geometries.

The Fréchet distance is a measure of similarity between curves that takes into account the location and ordering of the points along the curves.
Therefore it is often better than the Hausdorff distance.

This function accepts a ``densifyFraction`` argument. The function performs a segment
densification before computing the discrete Fréchet distance. The ``densifyFraction`` parameter
sets the fraction by which to densify each segment. Each segment will be split into a
number of equal-length subsegments, whose fraction of the total length is
closest to the given fraction.

This method can be used when the default approximation provided by :py:func:`~QgsGeometry.frechetDistance`
is not sufficient. Decreasing the ``densifyFraction`` parameter will make the
distance returned approach the true Fréchet distance for the geometries.

This method requires a QGIS build based on GEOS 3.7 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.6 or earlier.

.. seealso:: :py:func:`frechetDistance`

.. versionadded:: 3.20
%End

    QgsPointXY closestVertex( const QgsPointXY &point, int &closestVertexIndex /Out/, int &previousVertexIndex /Out/, int &nextVertexIndex /Out/, double &sqrDist /Out/ ) const;
%Docstring
Returns the vertex closest to the given point, the corresponding vertex index, squared distance snap point / target point
and the indices of the vertices before and after the closest vertex.

:param point: point to search for

:return: - closest point in geometry. If not found (empty geometry), returns null point and sqrDist is negative.
         - closestVertexIndex: will be set to the vertex index of the closest found vertex
         - previousVertexIndex: will be set to the vertex index of the previous vertex from the closest one. Will be set to -1 if not present.
         - nextVertexIndex: will be set to the vertex index of the next vertex after the closest one. Will be set to -1 if not present.
         - sqrDist: will be set to the square distance between the closest vertex and the specified point
%End

    double distanceToVertex( int vertex ) const;
%Docstring
Returns the distance along this geometry from its first vertex to the specified vertex.

:param vertex: vertex index to calculate distance to

:return: distance to vertex (following geometry), or -1 for invalid vertex numbers

.. warning::

   QgsGeometry objects are inherently Cartesian/planar geometries, and the distance
   returned by this method is calculated using strictly Cartesian mathematics.
%End

    double angleAtVertex( int vertex ) const;
%Docstring
Returns the bisector angle for this geometry at the specified vertex.

:param vertex: vertex index to calculate bisector angle at

:return: bisector angle, in radians clockwise from north

.. seealso:: :py:func:`interpolateAngle`
%End

    void adjacentVertices( int atVertex, int &beforeVertex /Out/, int &afterVertex /Out/ ) const;
%Docstring
Returns the indexes of the vertices before and after the given vertex index.

This function takes into account the following factors:

# If the given vertex index is at the end of a linestring,
  the adjacent index will be -1 (for "no adjacent vertex")
# If the given vertex index is at the end of a linear ring
  (such as in a polygon), the adjacent index will take into
  account the first vertex is equal to the last vertex (and will
  skip equal vertex positions).
%End

    bool insertVertex( double x, double y, int beforeVertex );
%Docstring
Insert a new vertex before the given vertex index,
ring and item (first number is index 0)
If the requested vertex number (beforeVertex.back()) is greater
than the last actual vertex on the requested ring and item,
it is assumed that the vertex is to be appended instead of inserted.
Returns ``False`` if atVertex does not correspond to a valid vertex
on this geometry (including if this geometry is a Point).
It is up to the caller to distinguish between
these error conditions.  (Or maybe we add another method to this
object to help make the distinction?)
%End

    bool insertVertex( const QgsPoint &point, int beforeVertex );
%Docstring
Insert a new vertex before the given vertex index,
ring and item (first number is index 0)
If the requested vertex number (beforeVertex.back()) is greater
than the last actual vertex on the requested ring and item,
it is assumed that the vertex is to be appended instead of inserted.
Returns ``False`` if atVertex does not correspond to a valid vertex
on this geometry (including if this geometry is a Point).
It is up to the caller to distinguish between
these error conditions.  (Or maybe we add another method to this
object to help make the distinction?)
%End

    bool addTopologicalPoint( const QgsPoint &point, double snappingTolerance = 1e-8, double segmentSearchEpsilon = 1e-12 );
%Docstring
Adds a vertex to the segment which intersect ``point`` but don't
already have a vertex there. Closest segment is identified using ``segmentSearchEpsilon``.
If a vertex already exists within ``snappingTolearnceDistance``, no additional vertex is inserted.

:return: ``True`` if point was added, ``False`` otherwise

.. versionadded:: 3.38
%End

    bool moveVertex( double x, double y, int atVertex );
%Docstring
Moves the vertex at the given position number
and item (first number is index 0)
to the given coordinates.
Returns ``False`` if atVertex does not correspond to a valid vertex
on this geometry
%End

    bool moveVertex( const QgsPoint &p, int atVertex );
%Docstring
Moves the vertex at the given position number
and item (first number is index 0)
to the given coordinates.
Returns ``False`` if atVertex does not correspond to a valid vertex
on this geometry
%End

    bool deleteVertex( int atVertex );
%Docstring
Deletes the vertex at the given position number and item
(first number is index 0)

:return: ``False`` if atVertex does not correspond to a valid vertex
         on this geometry (including if this geometry is a Point),
         or if the number of remaining vertices in the linestring
         would be less than two.
         It is up to the caller to distinguish between
         these error conditions.  (Or maybe we add another method to this
         object to help make the distinction?)
%End

    bool toggleCircularAtVertex( int atVertex );
%Docstring
Converts the vertex at the given position from/to circular

:return: ``False`` if atVertex does not correspond to a valid vertex
         on this geometry (including if this geometry is a Point),
         or if the specified vertex can't be converted (e.g. start/end points).

.. versionadded:: 3.20
%End

    QgsPoint vertexAt( int atVertex ) const;
%Docstring
Returns coordinates of a vertex.

:param atVertex: index of the vertex

:return: Coordinates of the vertex or empty :py:class:`QgsPoint` on error
%End

    double sqrDistToVertexAt( QgsPointXY &point /In/, int atVertex ) const;
%Docstring
Returns the squared Cartesian distance between the given point
to the given vertex index (vertex at the given position number,
ring and item (first number is index 0))
%End

    QgsGeometry nearestPoint( const QgsGeometry &other ) const;
%Docstring
Returns the nearest (closest) point on this geometry to another geometry.

.. seealso:: :py:func:`shortestLine`
%End

    QgsGeometry shortestLine( const QgsGeometry &other ) const;
%Docstring
Returns the shortest line joining this geometry to another geometry.

.. seealso:: :py:func:`nearestPoint`

.. warning::

   QgsGeometry objects are inherently Cartesian/planar geometries, and the line
   returned by this method is calculated using strictly Cartesian mathematics. See :py:class:`QgsDistanceArea`
   for similar methods which account for the curvature of an ellipsoidal body such as the Earth.
%End

    double closestVertexWithContext( const QgsPointXY &point, int &atVertex /Out/ ) const;
%Docstring
Searches for the closest vertex in this geometry to the given point.

:param point: Specifiest the point for search

:return: - The squared Cartesian distance is also returned in sqrDist, negative number on error
         - atVertex: Receives index of the closest vertex
%End

    double closestSegmentWithContext( const QgsPointXY &point, QgsPointXY &minDistPoint /Out/, int &nextVertexIndex /Out/, int *leftOrRightOfSegment /Out/ = 0, double epsilon = DEFAULT_SEGMENT_EPSILON ) const;
%Docstring
Searches for the closest segment of geometry to the given point

:param point: Specifies the point for search
:param epsilon: epsilon for segment snapping

:return: - The squared Cartesian distance is also returned in sqrDist, negative number on error
         - minDistPoint: Receives the nearest point on the segment
         - nextVertexIndex: Receives index of the next vertex after the closest segment. The vertex before the closest segment is always nextVertexIndex - 1
         - leftOrRightOfSegment: Out: Returns if the point is located on the left or right side of the geometry ( < 0 means left, > 0 means right, 0 indicates that the test was unsuccessful, e.g. for a point exactly on the line)
%End

    Qgis::GeometryOperationResult addRing( const QVector<QgsPointXY> &ring );
%Docstring
Adds a new ring to this geometry. This makes only sense for polygon and multipolygons.

:param ring: The ring to be added

:return: OperationResult a result code: success or reason of failure
%End

    Qgis::GeometryOperationResult addRing( QgsCurve *ring /Transfer/ );
%Docstring
Adds a new ring to this geometry. This makes only sense for polygon and multipolygons.

:param ring: The ring to be added

:return: OperationResult a result code: success or reason of failure
%End

 Qgis::GeometryOperationResult addPart( const QVector<QgsPointXY> &points, Qgis::GeometryType geomType = Qgis::GeometryType::Unknown ) /PyName=addPointsXY,Deprecated/;
%Docstring
Adds a new part to a the geometry.

:param points: points describing part to add
:param geomType: default geometry type to create if no existing geometry

:return: OperationResult a result code: success or reason of failure

.. deprecated:: QGIS 3.38
   - will be removed in QGIS 4.0. Use addPartV2 which accepts :py:class:`Qgis`.WkbType geometry type instead of :py:class:`Qgis`.GeometryType.
%End

    Qgis::GeometryOperationResult addPartV2( const QVector<QgsPointXY> &points, Qgis::WkbType wkbType = Qgis::WkbType::Unknown ) /PyName=addPointsXYV2/;
%Docstring
Adds a new part to a the geometry.

:param points: points describing part to add
:param wkbType: default WKB type to create if no existing geometry

:return: OperationResult a result code: success or reason of failure

.. versionadded:: 3.38
%End

 Qgis::GeometryOperationResult addPart( const QgsPointSequence &points, Qgis::GeometryType geomType = Qgis::GeometryType::Unknown ) /PyName=addPoints,Deprecated/;
%Docstring
Adds a new part to a the geometry.

:param points: points describing part to add
:param geomType: default geometry type to create if no existing geometry

:return: OperationResult a result code: success or reason of failure

.. deprecated:: QGIS 3.38
   - will be removed in QGIS 4.0. Use addPartV2 which accepts :py:class:`Qgis`.WkbType geometry type instead of :py:class:`Qgis`.GeometryType.
%End

    Qgis::GeometryOperationResult addPartV2( const QgsPointSequence &points, Qgis::WkbType wkbType = Qgis::WkbType::Unknown ) /PyName=addPointsV2/;
%Docstring
Adds a new part to a the geometry.

:param points: points describing part to add
:param wkbType: default WKB type to create if no existing geometry

:return: OperationResult a result code: success or reason of failure

.. versionadded:: 3.38
%End

 Qgis::GeometryOperationResult addPart( QgsAbstractGeometry *part /Transfer/, Qgis::GeometryType geomType = Qgis::GeometryType::Unknown ) /Deprecated/;
%Docstring
Adds a new part to this geometry.

:param part: part to add (ownership is transferred)
:param geomType: default geometry type to create if no existing geometry

:return: OperationResult a result code: success or reason of failure

.. deprecated:: QGIS 3.38
   - will be removed in QGIS 4.0. Use addPartV2 which accepts :py:class:`Qgis`.WkbType geometry type instead of :py:class:`Qgis`.GeometryType.
%End

    Qgis::GeometryOperationResult addPartV2( QgsAbstractGeometry *part /Transfer/, Qgis::WkbType wkbType = Qgis::WkbType::Unknown );
%Docstring
Adds a new part to this geometry.

:param part: part to add (ownership is transferred)
:param wkbType: default WKB type to create if no existing geometry

:return: OperationResult a result code: success or reason of failure

.. versionadded:: 3.38
%End

    Qgis::GeometryOperationResult addPart( const QgsGeometry &newPart ) /PyName=addPartGeometry/;
%Docstring
Adds a new island polygon to a multipolygon feature

:return: OperationResult a result code: success or reason of failure

.. note::

   available in python bindings as addPartGeometry
%End

    QgsGeometry removeInteriorRings( double minimumAllowedArea = -1 ) const;
%Docstring
Removes the interior rings from a (multi)polygon geometry. If the minimumAllowedArea
parameter is specified then only rings smaller than this minimum
area will be removed.
%End

    Qgis::GeometryOperationResult translate( double dx, double dy, double dz = 0.0, double dm = 0.0 );
%Docstring
Translates this geometry by dx, dy, dz and dm.

:return: OperationResult a result code: success or reason of failure
%End

    Qgis::GeometryOperationResult transform( const QgsCoordinateTransform &ct, Qgis::TransformDirection direction = Qgis::TransformDirection::Forward, bool transformZ = false ) throw( QgsCsException );
%Docstring
Transforms this geometry as described by the coordinate transform ``ct``.

The transformation defaults to a forward transform, but the direction can be swapped
by setting the ``direction`` argument.

By default, z-coordinates are not transformed, even if the coordinate transform
includes a vertical datum transformation. To transform z-coordinates, set
``transformZ`` to ``True``. This requires that the z coordinates in the geometry represent
height relative to the vertical datum of the source CRS (generally ellipsoidal heights)
and are expressed in its vertical units (generally meters).

:return: OperationResult a result code: success or reason of failure
%End

    Qgis::GeometryOperationResult transform( const QTransform &t, double zTranslate = 0.0, double zScale = 1.0, double mTranslate = 0.0, double mScale = 1.0 );
%Docstring
Transforms the x and y components of the geometry using a QTransform object ``t``.

Optionally, the geometry's z values can be scaled via ``zScale`` and translated via ``zTranslate``.
Similarly, m-values can be scaled via ``mScale`` and translated via ``mTranslate``.

:return: OperationResult a result code: success or reason of failure
%End

    Qgis::GeometryOperationResult rotate( double rotation, const QgsPointXY &center );
%Docstring
Rotate this geometry around the Z axis

:param rotation: clockwise rotation in degrees
:param center: rotation center

:return: OperationResult a result code: success or reason of failure
%End





    SIP_PYOBJECT splitGeometry( SIP_PYOBJECT splitLine /TypeHint="List[Union[QgsPoint, QgsPointXY]]"/, bool topological, bool splitFeature = true ) /TypeHint="Tuple[Qgis.GeometryOperationResult, Union[List[QgsPoint], List[QgsPointXY]], Union[List[QgsPoint], List[QgsPointXY]]]"/;
%Docstring
Splits this geometry according to a given line.

:param splitLine: the line that splits the geometry
:param topological: ``True`` if topological editing is enabled
:param splitFeature: Set to ``True`` if you want to split a feature, otherwise set to ``False`` to split parts

:return: a tuple (:py:class:`Qgis`.GeometryOperationResult, List[:py:class:`QgsGeometry`], List[Union[:py:class:`QgsPoint`, :py:class:`QgsPointXY`]]) (result code, list of new geometries, list of topological points)

Example:

.. code-block:: python

      geometry = QgsGeometry.fromWkt('CompoundCurveZ ((2749546.2003820720128715 1262904.45356595050543547 100, 2749557.82053794478997588 1262920.05570670193992555 200))')
      split_line = [QgsPoint(2749544.19, 1262914.79), QgsPoint(2749557.64, 1262897.30)]
      result, new_geometries, point_xy = geometry.splitGeometry(split_line, False)
      print(geometry.asWkt(2))
      > LineStringZ (2749549.12 1262908.38 125.14, 2749557.82 1262920.06 200)
%End
%MethodCode
    {
      int sipIsErr = 0;
      int state;

      if ( PyList_Check( a0 ) && PyList_GET_SIZE( a0 ) )
      {
        PyObject *p0 = PyList_GetItem( a0, 0 );
        if ( sipCanConvertToType( p0, sipType_QgsPointXY, SIP_NOT_NONE ) &&
             sipCanConvertToType( a0, sipType_QVector_0100QgsPointXY, SIP_NOT_NONE ) )
        {
          QVector<QgsGeometry> newGeometries;
          QVector<QgsPointXY> topologyTestPoints;

          QVector<QgsPointXY> *splitLine = reinterpret_cast<QVector<QgsPointXY> *>( sipConvertToType( a0, sipType_QVector_0100QgsPointXY, 0, SIP_NOT_NONE, &state, &sipIsErr ) );
          if ( sipIsErr )
          {
            sipReleaseType( splitLine, sipType_QVector_0100QgsPointXY, state );
          }
          else
          {
            Qgis::GeometryOperationResult result = sipCpp->splitGeometry( *splitLine, newGeometries, a1, topologyTestPoints, a2 );

            PyObject *o0 = sipConvertFromEnum( static_cast<int>( result ), sipType_Qgis_GeometryOperationResult );
            PyObject *o1 = sipConvertFromType( &newGeometries, sipType_QVector_0100QgsGeometry, Py_None );
            PyObject *o2 = sipConvertFromType( &topologyTestPoints, sipType_QVector_0100QgsPointXY, Py_None );

            sipRes = PyTuple_New( 3 );
            PyTuple_SET_ITEM( sipRes, 0, o0 );
            PyTuple_SET_ITEM( sipRes, 1, o1 );
            PyTuple_SET_ITEM( sipRes, 2, o2 );
          }
        }

        else if ( sipCanConvertToType( p0, sipType_QgsPoint, SIP_NOT_NONE ) &&
                  sipCanConvertToType( a0, sipType_QVector_0100QgsPoint, SIP_NOT_NONE ) )
        {
          QVector<QgsGeometry> newGeometries;
          QVector<QgsPoint> topologyTestPoints;

          QVector<QgsPoint> *splitLine = reinterpret_cast<QVector<QgsPoint> *>( sipConvertToType( a0, sipType_QVector_0100QgsPoint, 0, SIP_NOT_NONE, &state, &sipIsErr ) );
          if ( sipIsErr )
          {
            sipReleaseType( splitLine, sipType_QVector_0100QgsPoint, state );
          }
          else
          {
            Qgis::GeometryOperationResult result = sipCpp->splitGeometry( *splitLine, newGeometries, a1, topologyTestPoints, a2 );

            PyObject *o0 = sipConvertFromEnum( static_cast<int>( result ), sipType_Qgis_GeometryOperationResult );
            PyObject *o1 = sipConvertFromType( &newGeometries, sipType_QVector_0100QgsGeometry, Py_None );
            PyObject *o2 = sipConvertFromType( &topologyTestPoints, sipType_QVector_0100QgsPoint, Py_None );

            sipRes = PyTuple_New( 3 );
            PyTuple_SET_ITEM( sipRes, 0, o0 );
            PyTuple_SET_ITEM( sipRes, 1, o1 );
            PyTuple_SET_ITEM( sipRes, 2, o2 );
          }
        }
        else
        {
          sipIsErr = 1;
          PyErr_SetString( PyExc_TypeError, QStringLiteral( "Could not convert first argument to a list of QgsPoint or QgsPointXY." ).toUtf8().constData() );
        }
      }
      else
      {
        sipIsErr = 1;
        PyErr_SetString( PyExc_TypeError, QStringLiteral( "First argument is not a list of points or is empty." ).toUtf8().constData() );
      }
    }
%End

    Qgis::GeometryOperationResult splitGeometry( const QgsCurve *curve,  QVector<QgsGeometry> &newGeometries /Out/, bool preserveCircular, bool topological, QgsPointSequence &topologyTestPoints /Out/, bool splitFeature = true );
%Docstring
Splits this geometry according to a given curve.

:param curve: the curve that splits the geometry
\param[out] newGeometries list of new geometries that have been created with the ``splitLine``. If the geometry is 3D, a linear interpolation of the z value is performed on the geometry at split points, see example.
:param preserveCircular: whether if circular strings are preserved after splitting
:param topological: ``True`` if topological editing is enabled
\param[out] topologyTestPoints points that need to be tested for topological completeness in the dataset
:param splitFeature: Set to ``True`` if you want to split a feature, otherwise set to ``False`` to split parts

:return: OperationResult a result code: success or reason of failure

.. versionadded:: 3.16
%End

    Qgis::GeometryOperationResult reshapeGeometry( const QgsLineString &reshapeLineString );
%Docstring
Replaces a part of this geometry with another line

:return: OperationResult a result code: success or reason of failure
%End


    QgsGeometry makeDifference( const QgsGeometry &other ) const;
%Docstring
Returns the geometry formed by modifying this geometry such that it does not
intersect the other geometry.

:param other: geometry that should not be intersect

:return: difference geometry, or empty geometry if difference could not be calculated
%End

    QgsRectangle boundingBox() const;
%Docstring
Returns the bounding box of the geometry.

.. seealso:: :py:func:`orientedMinimumBoundingBox`
%End

    QgsBox3D boundingBox3D() const;
%Docstring
Returns the 3D bounding box of the geometry.

.. versionadded:: 3.34
%End

    QgsGeometry orientedMinimumBoundingBox( double &area /Out/, double &angle /Out/, double &width /Out/, double &height /Out/ ) const;
%Docstring
Returns the oriented minimum bounding box for the geometry, which is the smallest (by area)
rotated rectangle which fully encompasses the geometry. The area, angle (clockwise in degrees from North),
width and height of the rotated bounding box will also be returned.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

.. seealso:: :py:func:`boundingBox`
%End


    QgsGeometry minimalEnclosingCircle( QgsPointXY &center /Out/, double &radius /Out/, unsigned int segments = 36 ) const;
%Docstring
Returns the minimal enclosing circle for the geometry.

:param segments: Number of segments used to segment geometry. :py:func:`QgsEllipse.toPolygon`

:return: - the minimal enclosing circle as a QGIS geometry
         - center: Center of the minimal enclosing circle returneds
         - radius: Radius of the minimal enclosing circle returned
%End


    QgsGeometry orthogonalize( double tolerance = 1.0E-8, int maxIterations = 1000, double angleThreshold = 15.0 ) const;
%Docstring
Attempts to orthogonalize a line or polygon geometry by shifting vertices to make the geometries
angles either right angles or flat lines. This is an iterative algorithm which will loop until
either the vertices are within a specified tolerance of right angles or a set number of maximum
iterations is reached. The angle threshold parameter specifies how close to a right angle or
straight line an angle must be before it is attempted to be straightened.
%End

    QgsGeometry triangularWaves( double wavelength, double amplitude, bool strictWavelength = false ) const;
%Docstring
Constructs triangular waves along the boundary of the geometry, with the
specified ``wavelength`` and ``amplitude``.

By default the ``wavelength`` argument is treated as a "maximum wavelength", where the actual
wavelength will be dynamically adjusted so that an exact number of triangular waves are created
along the boundaries of the geometry. If ``strictWavelength`` is set to ``True`` then the ``wavelength``
will be used exactly and an incomplete pattern may be used for the final waveform.

.. seealso:: :py:func:`triangularWavesRandomized`

.. versionadded:: 3.24
%End

    QgsGeometry triangularWavesRandomized( double minimumWavelength, double maximumWavelength, double minimumAmplitude, double maximumAmplitude, unsigned long seed = 0 ) const;
%Docstring
Constructs randomized triangular waves along the boundary of the geometry, with the
specified wavelength and amplitude ranges.

The ``minimumWavelength`` and ``maximumWavelength`` arguments set the range for the randomized
wavelength. This is evaluated for each individual triangular waveform created along the geometry
boundaries, so the resultant geometry will consist of many different wavelengths.

Similarly, the ``minimumAmplitude`` and ``maximumAmplitude`` arguments define the range for the
randomized amplitude of the triangular components. Randomized amplitude values will be calculated
individually for triangles placed on each either side of the input geometry boundaries.

Optionally, a specific random ``seed`` can be used when generating points. If ``seed``
is 0, then a completely random sequence of points will be generated.

.. seealso:: :py:func:`triangularWaves`

.. versionadded:: 3.24
%End

    QgsGeometry squareWaves( double wavelength, double amplitude, bool strictWavelength = false ) const;
%Docstring
Constructs square waves along the boundary of the geometry, with the
specified ``wavelength`` and ``amplitude``.

By default the ``wavelength`` argument is treated as a "maximum wavelength", where the actual
wavelength will be dynamically adjusted so that an exact number of square waves are created
along the boundaries of the geometry. If ``strictWavelength`` is set to ``True`` then the ``wavelength``
will be used exactly and an incomplete pattern may be used for the final waveform.

.. seealso:: :py:func:`squareWavesRandomized`

.. versionadded:: 3.24
%End

    QgsGeometry squareWavesRandomized( double minimumWavelength, double maximumWavelength, double minimumAmplitude, double maximumAmplitude, unsigned long seed = 0 ) const;
%Docstring
Constructs randomized square waves along the boundary of the geometry, with the
specified wavelength and amplitude ranges.

The ``minimumWavelength`` and ``maximumWavelength`` arguments set the range for the randomized
wavelength. This is evaluated for each individual square waveform created along the geometry
boundaries, so the resultant geometry will consist of many different wavelengths.

Similarly, the ``minimumAmplitude`` and ``maximumAmplitude`` arguments define the range for the
randomized amplitude of the square components. Randomized amplitude values will be calculated
individually for squares placed on each either side of the input geometry boundaries.

Optionally, a specific random ``seed`` can be used when generating points. If ``seed``
is 0, then a completely random sequence of points will be generated.

.. seealso:: :py:func:`squareWaves`

.. versionadded:: 3.24
%End

    QgsGeometry roundWaves( double wavelength, double amplitude, bool strictWavelength = false ) const;
%Docstring
Constructs rounded (sine-like) waves along the boundary of the geometry, with the
specified ``wavelength`` and ``amplitude``.

By default the ``wavelength`` argument is treated as a "maximum wavelength", where the actual
wavelength will be dynamically adjusted so that an exact number of waves are created
along the boundaries of the geometry. If ``strictWavelength`` is set to ``True`` then the ``wavelength``
will be used exactly and an incomplete pattern may be used for the final waveform.

.. seealso:: :py:func:`roundWavesRandomized`

.. versionadded:: 3.24
%End

    QgsGeometry roundWavesRandomized( double minimumWavelength, double maximumWavelength, double minimumAmplitude, double maximumAmplitude, unsigned long seed = 0 ) const;
%Docstring
Constructs randomized rounded (sine-like) waves along the boundary of the geometry, with the
specified wavelength and amplitude ranges.

The ``minimumWavelength`` and ``maximumWavelength`` arguments set the range for the randomized
wavelength. This is evaluated for each individual waveform created along the geometry
boundaries, so the resultant geometry will consist of many different wavelengths.

Similarly, the ``minimumAmplitude`` and ``maximumAmplitude`` arguments define the range for the
randomized amplitude of the square components. Randomized amplitude values will be calculated
individually for waves placed on each either side of the input geometry boundaries.

Optionally, a specific random ``seed`` can be used when generating points. If ``seed``
is 0, then a completely random sequence of points will be generated.

.. seealso:: :py:func:`squareWaves`

.. versionadded:: 3.24
%End

    QgsGeometry applyDashPattern( const QVector< double > &pattern,
                                  Qgis::DashPatternLineEndingRule startRule = Qgis::DashPatternLineEndingRule::NoRule,
                                  Qgis::DashPatternLineEndingRule endRule = Qgis::DashPatternLineEndingRule::NoRule,
                                  Qgis::DashPatternSizeAdjustment adjustment = Qgis::DashPatternSizeAdjustment::ScaleBothDashAndGap,
                                  double patternOffset = 0 ) const;
%Docstring
Applies a dash pattern to a geometry, returning a MultiLineString geometry which is the
input geometry stroked along each line/ring with the specified ``pattern``.

The ``startRule`` and ``endRule`` options can be set to control how the dash pattern is adjusted
at line endings. If a ``startRule`` or ``endRule`` is set, the ``adjustment`` option defines whether
both dash and gaps, or only dash or gap sizes are adjusted to apply the rules.

The ``patternOffset`` option specifies how far along the pattern the result should start at.
The offset is applied AFTER any start/end rules are applied.

.. versionadded:: 3.24
%End

    QgsGeometry snappedToGrid( double hSpacing, double vSpacing, double dSpacing = 0, double mSpacing = 0 ) const;
%Docstring
Returns a new geometry with all points or vertices snapped to the closest point of the grid.

If the gridified geometry could not be calculated (or was totally collapsed) an empty geometry will be returned.
Note that snapping to grid may generate an invalid geometry in some corner cases.
It can also be thought as rounding the edges and it may be useful for removing errors.

:param hSpacing: Horizontal spacing of the grid (x axis). 0 to disable.
:param vSpacing: Vertical spacing of the grid (y axis). 0 to disable.
:param dSpacing: Depth spacing of the grid (z axis). 0 (default) to disable.
:param mSpacing: Custom dimension spacing of the grid (m axis). 0 (default) to disable.
%End

    bool removeDuplicateNodes( double epsilon = 4 * DBL_EPSILON, bool useZValues = false );
%Docstring
Removes duplicate nodes from the geometry, wherever removing the nodes does not result in a
degenerate geometry.

The ``epsilon`` parameter specifies the tolerance for coordinates when determining that
vertices are identical.

By default, z values are not considered when detecting duplicate nodes. E.g. two nodes
with the same x and y coordinate but different z values will still be considered
duplicate and one will be removed. If ``useZValues`` is ``True``, then the z values are
also tested and nodes with the same x and y but different z will be maintained.

Note that duplicate nodes are not tested between different parts of a multipart geometry. E.g.
a multipoint geometry with overlapping points will not be changed by this method.

The function will return ``True`` if nodes were removed, or ``False`` if no duplicate nodes
were found.
%End

    bool intersects( const QgsRectangle &rectangle ) const;
%Docstring
Returns ``True`` if this geometry exactly intersects with a ``rectangle``. This test is exact
and can be slow for complex geometries.

The GEOS library is used to perform the intersection test. Geometries which are not
valid may return incorrect results.

.. seealso:: :py:func:`boundingBoxIntersects`
%End

    bool intersects( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if this geometry exactly intersects with another ``geometry``. This test is exact
and can be slow for complex geometries.

The GEOS library is used to perform the intersection test. Geometries which are not
valid may return incorrect results.

.. note::

   For performance critical code, or when testing for intersection against many different
   geometries, consider using :py:class:`QgsGeometryEngine` instead. This approach can be many orders of magnitude
   faster than calling :py:func:`~QgsGeometry.intersects` directly. See :py:func:`~QgsGeometry.createGeometryEngine` for details on how to use the
   :py:class:`QgsGeometryEngine` class.

.. seealso:: :py:func:`boundingBoxIntersects`
%End

    bool boundingBoxIntersects( const QgsRectangle &rectangle ) const;
%Docstring
Returns ``True`` if the bounding box of this geometry intersects with a ``rectangle``. Since this
test only considers the bounding box of the geometry, is is very fast to calculate and handles invalid
geometries.

.. seealso:: :py:func:`intersects`
%End

    bool boundingBoxIntersects( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if the bounding box of this geometry intersects with the bounding box of another ``geometry``. Since this
test only considers the bounding box of the geometries, is is very fast to calculate and handles invalid
geometries.

.. seealso:: :py:func:`intersects`
%End

    bool contains( const QgsPointXY *p ) const;
%Docstring
Returns ``True`` if the geometry contains the point ``p``.
%End

    bool contains( double x, double y ) const;
%Docstring
Returns ``True`` if the geometry contains the point at (``x``, ``y``).

.. versionadded:: 3.38
%End

    bool contains( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if the geometry completely contains another ``geometry``.

.. note::

   For performance critical code, or when testing for contains against many different
   geometries, consider using :py:class:`QgsGeometryEngine` instead. This approach can be many orders of magnitude
   faster than calling :py:func:`~QgsGeometry.contains` directly. See :py:func:`~QgsGeometry.createGeometryEngine` for details on how to use the
   :py:class:`QgsGeometryEngine` class.
%End

    bool disjoint( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if the geometry is disjoint of another ``geometry``.

.. note::

   For performance critical code, or when testing for disjoint against many different
   geometries, consider using :py:class:`QgsGeometryEngine` instead. This approach can be many orders of magnitude
   faster than calling :py:func:`~QgsGeometry.disjoint` directly. See :py:func:`~QgsGeometry.createGeometryEngine` for details on how to use the
   :py:class:`QgsGeometryEngine` class.
%End

    bool touches( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if the geometry touches another ``geometry``.

.. note::

   For performance critical code, or when testing for touches against many different
   geometries, consider using :py:class:`QgsGeometryEngine` instead. This approach can be many orders of magnitude
   faster than calling :py:func:`~QgsGeometry.touches` directly. See :py:func:`~QgsGeometry.createGeometryEngine` for details on how to use the
   :py:class:`QgsGeometryEngine` class.
%End

    bool overlaps( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if the geometry overlaps another ``geometry``.

.. note::

   For performance critical code, or when testing for overlaps against many different
   geometries, consider using :py:class:`QgsGeometryEngine` instead. This approach can be many orders of magnitude
   faster than calling :py:func:`~QgsGeometry.overlaps` directly. See :py:func:`~QgsGeometry.createGeometryEngine` for details on how to use the
   :py:class:`QgsGeometryEngine` class.
%End

    bool within( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if the geometry is completely within another ``geometry``.

.. note::

   For performance critical code, or when testing for within against many different
   geometries, consider using :py:class:`QgsGeometryEngine` instead. This approach can be many orders of magnitude
   faster than calling :py:func:`~QgsGeometry.within` directly. See :py:func:`~QgsGeometry.createGeometryEngine` for details on how to use the
   :py:class:`QgsGeometryEngine` class.
%End

    bool crosses( const QgsGeometry &geometry ) const;
%Docstring
Returns ``True`` if the geometry crosses another ``geometry``.

.. note::

   For performance critical code, or when testing for crosses against many different
   geometries, consider using :py:class:`QgsGeometryEngine` instead. This approach can be many orders of magnitude
   faster than calling :py:func:`~QgsGeometry.crosses` directly. See :py:func:`~QgsGeometry.createGeometryEngine` for details on how to use the
   :py:class:`QgsGeometryEngine` class.
%End

    QgsGeometry buffer( double distance, int segments ) const;
%Docstring
Returns a buffer region around this geometry having the given width and with a specified number
of segments used to approximate curves

.. seealso:: :py:func:`singleSidedBuffer`

.. seealso:: :py:func:`taperedBuffer`
%End

    QgsGeometry buffer( double distance, int segments, Qgis::EndCapStyle endCapStyle, Qgis::JoinStyle joinStyle, double miterLimit ) const;
%Docstring
Returns a buffer region around the geometry, with additional style options.

:param distance: buffer distance
:param segments: for round joins, number of segments to approximate quarter-circle
:param endCapStyle: end cap style
:param joinStyle: join style for corners in geometry
:param miterLimit: limit on the miter ratio used for very sharp corners (JoinStyleMiter only)

.. seealso:: :py:func:`singleSidedBuffer`

.. seealso:: :py:func:`taperedBuffer`
%End

    QgsGeometry offsetCurve( double distance, int segments, Qgis::JoinStyle joinStyle, double miterLimit ) const;
%Docstring
Returns an offset line at a given distance and side from an input line.

:param distance: buffer distance
:param segments: for round joins, number of segments to approximate quarter-circle
:param joinStyle: join style for corners in geometry
:param miterLimit: limit on the miter ratio used for very sharp corners (JoinStyleMiter only)
%End

    QgsGeometry singleSidedBuffer( double distance, int segments, Qgis::BufferSide side,
                                   Qgis::JoinStyle joinStyle = Qgis::JoinStyle::Round,
                                   double miterLimit = 2.0 ) const;
%Docstring
Returns a single sided buffer for a (multi)line geometry. The buffer is only
applied to one side of the line.

:param distance: buffer distance
:param segments: for round joins, number of segments to approximate quarter-circle
:param side: side of geometry to buffer
:param joinStyle: join style for corners
:param miterLimit: limit on the miter ratio used for very sharp corners

:return: buffered geometry, or an empty geometry if buffer could not be
         calculated

.. seealso:: :py:func:`buffer`

.. seealso:: :py:func:`taperedBuffer`
%End

    QgsGeometry taperedBuffer( double startWidth, double endWidth, int segments ) const;
%Docstring
Calculates a variable width buffer ("tapered buffer") for a (multi)curve geometry.

The buffer begins at a width of ``startWidth`` at the start of each curve, and
ends at a width of ``endWidth``. Note that unlike :py:func:`~QgsGeometry.buffer` methods, ``startWidth``
and ``endWidth`` are the diameter of the buffer at these points, not the radius.

The ``segments`` argument specifies the number of segments to approximate quarter-circle
curves in the buffer.

Non (multi)curve input geometries will return a null output geometry.

.. seealso:: :py:func:`buffer`

.. seealso:: :py:func:`singleSidedBuffer`

.. seealso:: :py:func:`variableWidthBufferByM`

.. versionadded:: 3.2
%End

    QgsGeometry variableWidthBufferByM( int segments ) const;
%Docstring
Calculates a variable width buffer for a (multi)linestring geometry, where
the width at each node is taken from the linestring m values.

The ``segments`` argument specifies the number of segments to approximate quarter-circle
curves in the buffer.

Non (multi)linestring input geometries will return a null output geometry.

.. seealso:: :py:func:`buffer`

.. seealso:: :py:func:`singleSidedBuffer`

.. seealso:: :py:func:`taperedBuffer`

.. versionadded:: 3.2
%End

    QgsGeometry extendLine( double startDistance, double endDistance ) const;
%Docstring
Extends a (multi)line geometry by extrapolating out the start or end of the line
by a specified distance. Lines are extended using the bearing of the first or last
segment in the line.
%End

    QgsGeometry simplify( double tolerance ) const;
%Docstring
Returns a simplified version of this geometry using a specified tolerance value
%End

    QgsGeometry densifyByCount( int extraNodesPerSegment ) const;
%Docstring
Returns a copy of the geometry which has been densified by adding the specified
number of extra nodes within each segment of the geometry.
If the geometry has z or m values present then these will be linearly interpolated
at the added nodes.
Curved geometry types are automatically segmentized by this routine.

.. seealso:: :py:func:`densifyByDistance`
%End

    QgsGeometry densifyByDistance( double distance ) const;
%Docstring
Densifies the geometry by adding regularly placed extra nodes inside each segment
so that the maximum distance between any two nodes does not exceed the
specified ``distance``.
E.g. specifying a distance 3 would cause the segment [0 0] -> [10 0]
to be converted to [0 0] -> [2.5 0] -> [5 0] -> [7.5 0] -> [10 0], since
3 extra nodes are required on the segment and spacing these at 2.5 increments
allows them to be evenly spaced over the segment.
If the geometry has z or m values present then these will be linearly interpolated
at the added nodes.
Curved geometry types are automatically segmentized by this routine.

.. seealso:: :py:func:`densifyByCount`
%End

    QgsGeometry convertToCurves( double distanceTolerance = 1e-8, double angleTolerance = 1e-8 ) const;
%Docstring
Attempts to convert a non-curved geometry into a curved geometry type (e.g.
LineString to CompoundCurve, Polygon to CurvePolygon).

The ``distanceTolerance`` specifies the maximum deviation allowed between the original location
of vertices and where they would fall on the candidate curved geometry.

This method only consider a segments as suitable for replacing with an arc if the points are all
regularly spaced on the candidate arc. The ``pointSpacingAngleTolerance`` parameter specifies the maximum
angular deviation (in radians) allowed when testing for regular point spacing.

.. note::

   The API is considered EXPERIMENTAL and can be changed without a notice

.. versionadded:: 3.14
%End

    QgsGeometry centroid() const;
%Docstring
Returns the center of mass of a geometry.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

.. note::

   for line based geometries, the center point of the line is returned,
   and for point based geometries, the point itself is returned

.. seealso:: :py:func:`pointOnSurface`

.. seealso:: :py:func:`poleOfInaccessibility`
%End

    QgsGeometry pointOnSurface() const;
%Docstring
Returns a point guaranteed to lie on the surface of a geometry. While the :py:func:`~QgsGeometry.centroid`
of a geometry may be located outside of the geometry itself (e.g., for concave shapes),
the point on surface will always be inside the geometry.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

.. seealso:: :py:func:`centroid`

.. seealso:: :py:func:`poleOfInaccessibility`
%End

    QgsGeometry poleOfInaccessibility( double precision, double *distanceToBoundary /Out/ = 0 ) const;
%Docstring
Calculates the approximate pole of inaccessibility for a surface, which is the
most distant internal point from the boundary of the surface. This function
uses the 'polylabel' algorithm (Vladimir Agafonkin, 2016), which is an iterative
approach guaranteed to find the true pole of inaccessibility within a specified
tolerance. More precise tolerances require more iterations and will take longer
to calculate.
Optionally, the distance to the polygon boundary from the pole can be stored.

.. seealso:: :py:func:`centroid`

.. seealso:: :py:func:`pointOnSurface`
%End

    QgsGeometry largestEmptyCircle( double tolerance, const QgsGeometry &boundary = QgsGeometry() ) const throw( QgsNotSupportedException );
%Docstring
Constructs the Largest Empty Circle for a set of obstacle geometries, up to a
specified tolerance.

The Largest Empty Circle is the largest circle which has its center in the convex hull of the
obstacles (the boundary), and whose interior does not intersect with any obstacle.
The circle center is the point in the interior of the boundary which has the farthest distance from
the obstacles (up to tolerance). The circle is determined by the center point and a point lying on an
obstacle indicating the circle radius.
The implementation uses a successive-approximation technique over a grid of square cells covering the obstacles and boundary.
The grid is refined using a branch-and-bound algorithm.  Point containment and distance are computed in a performant
way by using spatial indexes.
Returns a two-point linestring, with one point at the center of the inscribed circle and the other
on the boundary of the inscribed circle.

This method requires QGIS builds based on GEOS 3.9 or later.

.. warning::

   the ``tolerance`` value must be a value greater than 0, or the algorithm may never converge on a solution

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.8 or earlier.


.. versionadded:: 3.20
%End

    QgsGeometry minimumWidth() const throw( QgsNotSupportedException );
%Docstring
Returns a linestring geometry which represents the minimum diameter of the geometry.

The minimum diameter is defined to be the width of the smallest band that
contains the geometry, where a band is a strip of the plane defined
by two parallel lines. This can be thought of as the smallest hole that the geometry
can be moved through, with a single rotation.

This method requires a QGIS build based on GEOS 3.6 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.5 or earlier.

.. versionadded:: 3.20
%End

    double minimumClearance() const throw( QgsNotSupportedException );
%Docstring
Computes the minimum clearance of a geometry.

The minimum clearance is the smallest amount by which
a vertex could be moved to produce an invalid polygon, a non-simple linestring, or a multipoint with
repeated points.  If a geometry has a minimum clearance of 'eps', it can be said that:

- No two distinct vertices in the geometry are separated by less than 'eps'
- No vertex is closer than 'eps' to a line segment of which it is not an endpoint.

If the minimum clearance cannot be defined for a geometry (such as with a single point, or a multipoint
whose points are identical) a value of infinity will be returned.

If an error occurs while calculating the clearance NaN will be returned.

This method requires a QGIS build based on GEOS 3.6 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.5 or earlier.

.. versionadded:: 3.20
%End

    QgsGeometry minimumClearanceLine() const throw( QgsNotSupportedException );
%Docstring
Returns a LineString whose endpoints define the minimum clearance of a geometry.

If the geometry has no minimum clearance, an empty LineString will be returned.

This method requires a QGIS build based on GEOS 3.6 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.5 or earlier.

.. versionadded:: 3.20
%End

    QgsGeometry convexHull() const;
%Docstring
Returns the smallest convex polygon that contains all the points in the geometry.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.
%End

    QgsGeometry concaveHull( double targetPercent, bool allowHoles = false ) const throw( QgsNotSupportedException );
%Docstring
Returns a possibly concave polygon that contains all the points in the geometry.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.10 or earlier.

.. versionadded:: 3.28
%End

    QgsGeometry voronoiDiagram( const QgsGeometry &extent = QgsGeometry(), double tolerance = 0.0, bool edgesOnly = false ) const;
%Docstring
Creates a Voronoi diagram for the nodes contained within the geometry.

Returns the Voronoi polygons for the nodes contained within the geometry.
If ``extent`` is specified then it will be used as a clipping envelope for the diagram.
If no extent is set then the clipping envelope will be automatically calculated.
In either case the diagram will be clipped to the larger of the provided envelope
OR the envelope surrounding all input nodes.
The ``tolerance`` parameter specifies an optional snapping tolerance which can
be used to improve the robustness of the diagram calculation.
If ``edgesOnly`` is ``True`` than line string boundary geometries will be returned
instead of polygons.
An empty geometry will be returned if the diagram could not be calculated.
%End

    QgsGeometry delaunayTriangulation( double tolerance = 0.0, bool edgesOnly = false ) const;
%Docstring
Returns the Delaunay triangulation for the vertices of the geometry.
The ``tolerance`` parameter specifies an optional snapping tolerance which can
be used to improve the robustness of the triangulation.
If ``edgesOnly`` is ``True`` than line string boundary geometries will be returned
instead of polygons.
An empty geometry will be returned if the diagram could not be calculated.

.. seealso:: :py:func:`constrainedDelaunayTriangulation`
%End

    QgsGeometry constrainedDelaunayTriangulation() const throw( QgsNotSupportedException );
%Docstring
Returns a constrained Delaunay triangulation for the vertices of the geometry.

An empty geometry will be returned if the triangulation could not be calculated.

This method requires a QGIS build based on GEOS 3.11 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.10 or earlier.

.. seealso:: :py:func:`delaunayTriangulation`

.. versionadded:: 3.36
%End

    Qgis::CoverageValidityResult validateCoverage( double gapWidth, QgsGeometry *invalidEdges /Out/ = 0 ) const throw( QgsNotSupportedException );
%Docstring
Analyze a coverage (represented as a collection of polygonal geometry with exactly matching edge
geometry) to find places where the assumption of exactly matching edges is not met.

The input geometry is the polygonal coverage to access, stored in a geometry collection. All members must be POLYGON
or MULTIPOLYGON.

:param gapWidth: The maximum width of gaps to detect.

:return: - validity check result
         - invalidEdges: When there are invalidities in the coverage, will be set with a geometry collection of the same length as the input, with a MULTILINESTRING of the error edges for each invalid polygon, or an EMPTY where the polygon is a valid participant in the coverage.

This method requires a QGIS build based on GEOS 3.12 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.11 or earlier.

.. seealso:: :py:func:`simplifyCoverageVW`

.. versionadded:: 3.36
%End

    QgsGeometry simplifyCoverageVW( double tolerance, bool preserveBoundary ) const throw( QgsNotSupportedException );
%Docstring
Operates on a coverage (represented as a list of polygonal geometry with exactly matching edge geometry) to apply
a Visvalingam–Whyatt simplification to the edges, reducing complexity in proportion with the provided tolerance,
while retaining a valid coverage (no edges will cross or touch after the simplification).

Geometries never disappear, but they may be simplified down to just a triangle. Also, some invalid geoms
(such as Polygons which have too few non-repeated points) will be returned unchanged.

If the input dataset is not a valid coverage due to overlaps, it will still be simplified, but invalid topology
such as crossing edges will still be invalid.

:param tolerance: A tolerance parameter in linear units.
:param preserveBoundary: Set to ``True`` to preserve the outside edges of the coverage without simplification, or ``False`` to allow them to be simplified.

This method requires a QGIS build based on GEOS 3.12 or later.

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.11 or earlier.

.. seealso:: :py:func:`validateCoverage`

.. versionadded:: 3.36
%End

    QgsGeometry unionCoverage() const;
%Docstring
Optimized union algorithm for polygonal inputs that are correctly noded and do not overlap.
It may generate an error (returning a null geometry) for inputs that do not satisfy this constraint,
however this is not guaranteed.

The input geometry is the polygonal coverage to union, stored in a geometry collection.
All members must be POLYGON or MULTIPOLYGON.

.. seealso:: :py:func:`validateCoverage`

.. versionadded:: 3.36
%End

    QgsGeometry node() const;
%Docstring
Returns a (Multi)LineString representing the fully noded version of a collection of linestrings.

The noding preserves all of the input nodes, and introduces the least possible number of new nodes.
The resulting linework is dissolved (duplicate lines are removed).

The input geometry type should be a (Multi)LineString.

.. versionadded:: 3.20
%End

    QgsGeometry sharedPaths( const QgsGeometry &other ) const;
%Docstring
Find paths shared between the two given lineal geometries (this and ``other``).

Returns a GeometryCollection having two elements:

- first element is a MultiLineString containing shared paths
  having the same direction on both inputs
- second element is a MultiLineString containing shared paths
  having the opposite direction on the two inputs

Returns a null geometry on exception.

.. versionadded:: 3.20
%End

    QgsGeometry subdivide( int maxNodes = 256, const QgsGeometryParameters &parameters = QgsGeometryParameters() ) const;
%Docstring
Subdivides the geometry. The returned geometry will be a collection containing subdivided parts
from the original geometry, where no part has more then the specified maximum number of nodes (``maxNodes``).

This is useful for dividing a complex geometry into less complex parts, which are better able to be spatially
indexed and faster to perform further operations such as intersects on. The returned geometry parts may
not be valid and may contain self-intersections.

The minimum allowed value for ``maxNodes`` is 8.

Curved geometries will be segmentized before subdivision.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

Since QGIS 3.28 the optional ``parameters`` argument can be used to specify parameters which
control the subdivision results.
%End

    QgsGeometry interpolate( double distance ) const;
%Docstring
Returns an interpolated point on the geometry at the specified ``distance``.

If the original geometry is a polygon type, the boundary of the polygon
will be used during interpolation. If the original geometry is a point
type, a null geometry will be returned.

If z or m values are present, the output z and m will be interpolated using
the existing vertices' z or m values.

If the input is a NULL geometry, the output will also be a NULL geometry.

.. seealso:: :py:func:`lineLocatePoint`
%End

    double lineLocatePoint( const QgsGeometry &point ) const;
%Docstring
Returns a distance representing the location along this linestring of the closest point
on this linestring geometry to the specified point. Ie, the returned value indicates
how far along this linestring you need to traverse to get to the closest location
where this linestring comes to the specified point.

:param point: point to seek proximity to

:return: distance along line, or -1 on error

.. note::

   only valid for linestring geometries

.. seealso:: :py:func:`interpolate`
%End

    double interpolateAngle( double distance ) const;
%Docstring
Returns the angle parallel to the linestring or polygon boundary at the specified distance
along the geometry. Angles are in radians, clockwise from north.
If the distance coincides precisely at a node then the average angle from the segment either side
of the node is returned.

:param distance: distance along geometry

.. seealso:: :py:func:`angleAtVertex`
%End

    QgsGeometry intersection( const QgsGeometry &geometry, const QgsGeometryParameters &parameters = QgsGeometryParameters() ) const;
%Docstring
Returns a geometry representing the points shared by this geometry and other.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

Since QGIS 3.28 the optional ``parameters`` argument can be used to specify parameters which
control the intersection results.
%End

    QgsGeometry clipped( const QgsRectangle &rectangle );
%Docstring
Clips the geometry using the specified ``rectangle``.

Performs a fast, non-robust intersection between the geometry and
a ``rectangle``. The returned geometry may be invalid.
%End

    QgsGeometry combine( const QgsGeometry &geometry, const QgsGeometryParameters &parameters = QgsGeometryParameters() ) const;
%Docstring
Returns a geometry representing all the points in this geometry and other (a
union geometry operation).

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

.. note::

   this operation is not called union since its a reserved word in C++.

Since QGIS 3.28 the optional ``parameters`` argument can be used to specify parameters which
control the union results.
%End

    QgsGeometry mergeLines() const;
%Docstring
Merges any connected lines in a LineString/MultiLineString geometry and
converts them to single line strings.

:return: a LineString or MultiLineString geometry, with any connected lines
         joined. An empty geometry will be returned if the input geometry was not a
         MultiLineString geometry.
%End

    QgsGeometry difference( const QgsGeometry &geometry, const QgsGeometryParameters &parameters = QgsGeometryParameters() ) const;
%Docstring
Returns a geometry representing the points making up this geometry that do not make up other.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

Since QGIS 3.28 the optional ``parameters`` argument can be used to specify parameters which
control the difference results.
%End

    QgsGeometry symDifference( const QgsGeometry &geometry, const QgsGeometryParameters &parameters = QgsGeometryParameters() ) const;
%Docstring
Returns a geometry representing the points making up this geometry that do not make up other.

If the input is a NULL geometry, the output will also be a NULL geometry.

If an error was encountered while creating the result, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

Since QGIS 3.28 the optional ``parameters`` argument can be used to specify parameters which
control the difference results.
%End

    QgsGeometry extrude( double x, double y );
%Docstring
Returns an extruded version of this geometry.
%End


    SIP_PYOBJECT randomPointsInPolygon( int count, unsigned long seed = 0 ) const /TypeHint="QgsPolylineXY"/;
%Docstring
Returns a list of ``count`` random points generated inside a (multi)polygon geometry.

Optionally, a specific random ``seed`` can be used when generating points. If ``seed``
is 0, then a completely random sequence of points will be generated.

This method works only with (multi)polygon geometry types.

:raises TypeError: if the geometry is not a polygon type

:raises ValueError: if the geometry is null

.. versionadded:: 3.10
%End
%MethodCode
    const Qgis::GeometryType type = sipCpp->type();
    if ( sipCpp->isNull() )
    {
      PyErr_SetString( PyExc_ValueError, QStringLiteral( "Cannot generate points inside a null geometry." ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else if ( type != Qgis::GeometryType::Polygon )
    {
      PyErr_SetString( PyExc_TypeError, QStringLiteral( "Cannot generate points inside a %1 geometry. Only Polygon types are permitted." ).arg( QgsWkbTypes::displayString( sipCpp->wkbType() ) ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else
    {
      const sipTypeDef *qvector_type = sipFindType( "QVector<QgsPointXY>" );
      sipRes = sipConvertFromNewType( new QVector< QgsPointXY >( sipCpp->randomPointsInPolygon( a0, a1 ) ), qvector_type, Py_None );
    }
%End



    int wkbSize( QgsAbstractGeometry::WkbFlags flags = QgsAbstractGeometry::WkbFlags() ) const;
%Docstring
Returns the length of the QByteArray returned by :py:func:`~QgsGeometry.asWkb`

The optional ``flags`` argument specifies flags controlling WKB export behavior

.. versionadded:: 3.16
%End

    QByteArray asWkb( QgsAbstractGeometry::WkbFlags flags = QgsAbstractGeometry::WkbFlags() ) const;
%Docstring
Export the geometry to WKB

The optional ``flags`` argument specifies flags controlling WKB export behavior (since QGIS 3.14).
%End

    QString asWkt( int precision = 17 ) const;
%Docstring
Exports the geometry to WKT

:return: ``True`` in case of success and ``False`` else

.. note::

   precision parameter added in QGIS 2.4
%End

    SIP_PYOBJECT __repr__();
%MethodCode
    QString str;
    if ( sipCpp->isNull() )
      str = QStringLiteral( "<QgsGeometry: null>" );
    else
    {
      QString wkt = sipCpp->asWkt();
      if ( wkt.length() > 1000 )
        wkt = wkt.left( 1000 ) + QStringLiteral( "..." );
      str = QStringLiteral( "<QgsGeometry: %1>" ).arg( wkt );
    }
    sipRes = PyUnicode_FromString( str.toUtf8().constData() );
%End

    QString asJson( int precision = 17 ) const;
%Docstring
Exports the geometry to a GeoJSON string.
%End


    QVector< QgsGeometry > coerceToType( Qgis::WkbType type, double defaultZ = 0, double defaultM = 0 ) const;
%Docstring
Attempts to coerce this geometry into the specified destination ``type``.

This method will do anything possible to force the current geometry into the specified type. E.g.

- lines or polygons will be converted to points by return either a single multipoint geometry or multiple
  single point geometries.
- polygons will be converted to lines by extracting their exterior and interior rings, returning
  either a multilinestring or multiple single line strings as dictated by ``type``.
- lines will be converted to polygon rings if ``type`` is a polygon type
- curved geometries will be segmented if ``type`` is non-curved.
- multi geometries will be converted to a list of single geometries
- single geometries will be upgraded to multi geometries
- z or m values will be added or dropped as required.

Since QGIS 3.24, the parameters ``defaultZ`` and ``defaultM`` control the dimension value added when promoting geometries
to Z, M or ZM versions.
By default 0.0 is used for Z and M.

.. note::

   This method is much stricter than :py:func:`~QgsGeometry.convertToType`, as it considers the exact WKB type
   of geometries instead of the geometry family (point/line/polygon), and tries more exhaustively
   to coerce geometries to the desired ``type``. It also correctly maintains curves and z/m values
   wherever appropriate.

.. versionadded:: 3.14
%End

    QgsGeometry convertToType( Qgis::GeometryType destType, bool destMultipart = false ) const;
%Docstring
Try to convert the geometry to the requested type

:param destType: the geometry type to be converted to
:param destMultipart: determines if the output geometry will be multipart or not

:return: the converted geometry or ``None`` if the conversion fails.

.. note::

   The :py:func:`~QgsGeometry.coerceToType` method applies much stricter and more exhaustive attempts to convert
   between geometry types, and is recommended instead of this method. This method force drops
   curves and any z or m values present in the geometry.
%End



    SIP_PYOBJECT asPoint() const /TypeHint="QgsPointXY"/;
%Docstring
Returns the contents of the geometry as a 2-dimensional point.

Any z or m values present in the geometry will be discarded.

This method works only with single-point geometry types.

:raises TypeError: if the geometry is not a single-point type (or a multipoint containing a single point)

:raises ValueError: if the geometry is null
%End
%MethodCode
    if ( sipCpp->isNull() )
    {
      PyErr_SetString( PyExc_ValueError, QStringLiteral( "Null geometry cannot be converted to a point." ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else
    {
      const QgsAbstractGeometry *geom = sipCpp->constGet();
      if ( QgsWkbTypes::flatType( geom->simplifiedTypeRef()->wkbType() ) != Qgis::WkbType::Point )
      {
        PyErr_SetString( PyExc_TypeError, QStringLiteral( "%1 geometry cannot be converted to a point. Only Point types are permitted." ).arg( QgsWkbTypes::displayString( geom->wkbType() ) ).toUtf8().constData() );
        sipIsErr = 1;
      }
      else
      {
        sipRes = sipConvertFromNewType( new QgsPointXY( sipCpp->asPoint() ), sipType_QgsPointXY, Py_None );
      }
    }
%End


    SIP_PYOBJECT asPolyline() const /TypeHint="QgsPolylineXY"/;
%Docstring
Returns the contents of the geometry as a polyline.

Any z or m values present in the geometry will be discarded. If the geometry is a curved line type
(such as a CircularString), it will be automatically segmentized.

This method works only with single-line (or single-curve).

:raises TypeError: if the geometry is not a single-line type

:raises ValueError: if the geometry is null
%End
%MethodCode
    const Qgis::WkbType type = sipCpp->wkbType();
    if ( sipCpp->isNull() )
    {
      PyErr_SetString( PyExc_ValueError, QStringLiteral( "Null geometry cannot be converted to a polyline." ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else if ( QgsWkbTypes::geometryType( type ) != Qgis::GeometryType::Line || QgsWkbTypes::isMultiType( type ) )
    {
      PyErr_SetString( PyExc_TypeError, QStringLiteral( "%1 geometry cannot be converted to a polyline. Only single line or curve types are permitted." ).arg( QgsWkbTypes::displayString( type ) ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else
    {
      const sipTypeDef *qvector_type = sipFindType( "QVector< QgsPointXY >" );
      sipRes = sipConvertFromNewType( new QgsPolylineXY( sipCpp->asPolyline() ), qvector_type, Py_None );
    }
%End


    SIP_PYOBJECT asPolygon() const /TypeHint="QgsPolygonXY"/;
%Docstring
Returns the contents of the geometry as a polygon.

Any z or m values present in the geometry will be discarded. If the geometry is a curved polygon type
(such as a CurvePolygon), it will be automatically segmentized.

This method works only with single-polygon (or single-curve polygon) geometry types.

:raises TypeError: if the geometry is not a single-polygon type

:raises ValueError: if the geometry is null
%End
%MethodCode
    const Qgis::WkbType type = sipCpp->wkbType();
    if ( sipCpp->isNull() )
    {
      PyErr_SetString( PyExc_ValueError, QStringLiteral( "Null geometry cannot be converted to a polygon." ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else if ( QgsWkbTypes::geometryType( type ) != Qgis::GeometryType::Polygon || QgsWkbTypes::isMultiType( type ) )
    {
      PyErr_SetString( PyExc_TypeError, QStringLiteral( "%1 geometry cannot be converted to a polygon. Only single polygon or curve polygon types are permitted." ).arg( QgsWkbTypes::displayString( type ) ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else
    {
      const sipTypeDef *qvector_type = sipFindType( "QVector<QVector<QgsPointXY>>" );
      sipRes = sipConvertFromNewType( new QgsPolygonXY( sipCpp->asPolygon() ), qvector_type, Py_None );
    }
%End


    SIP_PYOBJECT asMultiPoint() const /TypeHint="QgsMultiPointXY"/;
%Docstring
Returns the contents of the geometry as a multi-point.

Any z or m values present in the geometry will be discarded.

This method works only with multi-point geometry types.

:raises TypeError: if the geometry is not a multi-point type

:raises ValueError: if the geometry is null
%End
%MethodCode
    const Qgis::WkbType type = sipCpp->wkbType();
    if ( sipCpp->isNull() )
    {
      PyErr_SetString( PyExc_ValueError, QStringLiteral( "Null geometry cannot be converted to a multipoint." ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else if ( QgsWkbTypes::geometryType( type ) != Qgis::GeometryType::Point || !QgsWkbTypes::isMultiType( type ) )
    {
      PyErr_SetString( PyExc_TypeError, QStringLiteral( "%1 geometry cannot be converted to a multipoint. Only multipoint types are permitted." ).arg( QgsWkbTypes::displayString( type ) ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else
    {
      const sipTypeDef *qvector_type = sipFindType( "QVector< QgsPointXY >" );
      sipRes = sipConvertFromNewType( new QgsPolylineXY( sipCpp->asMultiPoint() ), qvector_type, Py_None );
    }
%End


    SIP_PYOBJECT asMultiPolyline() const /TypeHint="QgsMultiPolylineXY"/;
%Docstring
Returns the contents of the geometry as a multi-linestring.

Any z or m values present in the geometry will be discarded. If the geometry is a curved line type
(such as a MultiCurve), it will be automatically segmentized.

This method works only with multi-linestring (or multi-curve) geometry types.

:raises TypeError: if the geometry is not a multi-linestring type

:raises ValueError: if the geometry is null
%End
%MethodCode
    const Qgis::WkbType type = sipCpp->wkbType();
    if ( sipCpp->isNull() )
    {
      PyErr_SetString( PyExc_ValueError, QStringLiteral( "Null geometry cannot be converted to a multilinestring." ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else if ( QgsWkbTypes::geometryType( type ) != Qgis::GeometryType::Line || !QgsWkbTypes::isMultiType( type ) )
    {
      PyErr_SetString( PyExc_TypeError, QStringLiteral( "%1 geometry cannot be converted to a multilinestring. Only multi linestring or curves are permitted." ).arg( QgsWkbTypes::displayString( type ) ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else
    {
      const sipTypeDef *qvector_type = sipFindType( "QVector<QVector<QgsPointXY>>" );
      sipRes = sipConvertFromNewType( new QgsMultiPolylineXY( sipCpp->asMultiPolyline() ), qvector_type, Py_None );
    }
%End


    SIP_PYOBJECT asMultiPolygon() const /TypeHint="QgsMultiPolygonXY"/;
%Docstring
Returns the contents of the geometry as a multi-polygon.

Any z or m values present in the geometry will be discarded. If the geometry is a curved polygon type
(such as a MultiSurface), it will be automatically segmentized.

This method works only with multi-polygon (or multi-curve polygon) geometry types.

:raises TypeError: if the geometry is not a multi-polygon type

:raises ValueError: if the geometry is null
%End
%MethodCode
    const Qgis::WkbType type = sipCpp->wkbType();
    if ( sipCpp->isNull() )
    {
      PyErr_SetString( PyExc_ValueError, QStringLiteral( "Null geometry cannot be converted to a multipolygon." ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else if ( QgsWkbTypes::geometryType( type ) != Qgis::GeometryType::Polygon || !QgsWkbTypes::isMultiType( type ) )
    {
      PyErr_SetString( PyExc_TypeError, QStringLiteral( "%1 geometry cannot be converted to a multipolygon. Only multi polygon or curves are permitted." ).arg( QgsWkbTypes::displayString( type ) ).toUtf8().constData() );
      sipIsErr = 1;
    }
    else
    {
      const sipTypeDef *qvector_type = sipFindType( "QVector<QVector<QVector<QgsPointXY>>>" );
      sipRes = sipConvertFromNewType( new QgsMultiPolygonXY( sipCpp->asMultiPolygon() ), qvector_type, Py_None );
    }
%End

    QVector<QgsGeometry> asGeometryCollection() const;
%Docstring
Returns contents of the geometry as a list of geometries
%End

    QPointF asQPointF() const /HoldGIL/;
%Docstring
Returns contents of the geometry as a QPointF if wkbType is WKBPoint,
otherwise returns a null QPointF.
%End

    QPolygonF asQPolygonF() const /HoldGIL/;
%Docstring
Returns contents of the geometry as a QPolygonF.

If geometry is a linestring, then the result will be an open QPolygonF.
If the geometry is a polygon, then the result will be a closed QPolygonF
of the geometry's exterior ring.

If the geometry is a multi-part geometry, then only the first part will
be considered when converting to a QPolygonF.
%End

    bool deleteRing( int ringNum, int partNum = 0 );
%Docstring
Deletes a ring in polygon or multipolygon.
Ring 0 is outer ring and can't be deleted.

:return: ``True`` on success
%End

    bool deletePart( int partNum );
%Docstring
Deletes part identified by the part number

:return: ``True`` on success
%End

    bool convertToMultiType();
%Docstring
Converts single type geometry into multitype geometry
e.g. a polygon into a multipolygon geometry with one polygon
If it is already a multipart geometry, it will return ``True`` and
not change the geometry.

:return: ``True`` in case of success and ``False`` else
%End

    bool convertToCurvedMultiType();
%Docstring
Converts a geometry into a multitype geometry of curve kind (when there
is a corresponding curve type).
e.g. a polygon into a multisurface geometry with one polygon,
a multipolygon into a multisurface, a linestring into a multicurve
geometry with one linestring, or a multilinestring into a multicurve.
If it is already a multipart curve geometry, it will return ``True`` and
not change the geometry. It will also return ``True`` and do nothing if
the current geometry is a multipoint or a geometry collection. A single
point will be transformed to a multipoint.

:return: ``True`` in case of success and ``False`` else

.. versionadded:: 3.30
%End

    bool convertToSingleType();
%Docstring
Converts multi type geometry into single type geometry
e.g. a multipolygon into a polygon geometry. Only the first part of the
multi geometry will be retained.
If it is already a single part geometry, it will return ``True`` and
not change the geometry.

:return: ``True`` in case of success and ``False`` else
%End

    bool convertGeometryCollectionToSubclass( Qgis::GeometryType geomType );
%Docstring
Converts geometry collection to a the desired geometry type subclass (multi-point,
multi-linestring or multi-polygon). Child geometries of different type are filtered out.
Does nothing the geometry is not a geometry collection. May leave the geometry
empty if none of the child geometries match the desired type.

:return: ``True`` in case of success and ``False`` else

.. versionadded:: 3.2
%End

 int avoidIntersections( const QList<QgsVectorLayer *> &avoidIntersectionsLayers ) /Deprecated/;

%Docstring
Modifies geometry to avoid intersections with the layers specified in project properties

:param avoidIntersectionsLayers: list of layers to check for intersections

:return: 0 in case of success,
         1 if geometry is not of polygon type,
         2 if avoid intersection would change the geometry type,
         3 at least one geometry intersected is invalid. The algorithm may not work and return the same geometry as the input. You must fix your intersecting geometries.
         4 if the geometry is not intersected by one of the geometries present in the provided layers.

.. deprecated::
   QGIS 3.34
%End

    Qgis::GeometryOperationResult avoidIntersectionsV2( const QList<QgsVectorLayer *> &avoidIntersectionsLayers );

%Docstring
Modifies geometry to avoid intersections with the layers specified in project properties

:param avoidIntersectionsLayers: list of layers to check for intersections

:return: Success                  in case of success
         InvalidInputGeometryType if geometry is not of polygon type
         GeometryTypeHasChanged   if avoid intersection has changed the geometry type
         InvalidBaseGeometry      at least one geometry intersected is invalid. The algorithm may not work and return the same geometry as the input. You must fix your intersecting geometries.
         NothingHappened          if the geometry is not intersected by one of the geometries present in the provided layers.

.. versionadded:: 3.34
%End

    QgsGeometry makeValid( Qgis::MakeValidMethod method = Qgis::MakeValidMethod::Linework, bool keepCollapsed = false ) const throw( QgsNotSupportedException );
%Docstring
Attempts to make an invalid geometry valid without losing vertices.

Already-valid geometries are returned without further intervention.
In case of full or partial dimensional collapses, the output geometry may be a collection
of lower-to-equal dimension geometries or a geometry of lower dimension.
Single polygons may become multi-geometries in case of self-intersections.
It preserves Z values, but M values will be dropped.

If an error was encountered during the process, more information can be retrieved
by calling :py:func:`~QgsGeometry.lastError` on the returned geometry.

The ``method`` and ``keepCollapsed`` arguments are available since QGIS 3.28.
They require builds based on GEOS 3.10 or later.

:return: new valid QgsGeometry or null geometry on error

:raises QgsNotSupportedException: on QGIS builds based on GEOS 3.9 or earlier when the ``method`` is not Qgis.MakeValidMethod.Linework or the ``keepCollapsed`` option is set.
%End

    Qgis::AngularDirection polygonOrientation() const;
%Docstring
Returns the orientation of the polygon.

.. warning::

   Only the first exterior ring is taken to perform this operation. In case of degenerate orders,
   you have to perform in deep verification.

.. warning::

   returns :py:class:`Qgis`.AngularDirection.NoOrientation if the geometry is not a polygon type or empty

.. versionadded:: 3.36
%End

    bool isPolygonCounterClockwise() const;
%Docstring
Returns True if the Polygon is counter-clockwise.

.. warning::

   Only the first exterior ring is taken to perform this operation. In case of degenerate orders,
   you have to perform in deep verification.

.. warning::

   returns false if the geometry is not a polygon type or empty


.. seealso:: :py:func:`isPolygonClockwise`

.. seealso:: :py:func:`forcePolygonClockwise`

.. seealso:: :py:func:`forcePolygonCounterClockwise`

.. versionadded:: 3.36
%End

    bool isPolygonClockwise() const;
%Docstring
Returns True if the Polygon is clockwise.

.. warning::

   Only the first exterior ring is taken to perform this operation. In case of degenerate orders,
   you have to perform in deep verification.

.. warning::

   returns true if the geometry is not a polygon type or empty


.. seealso:: :py:func:`isPolygonCounterClockwise`

.. seealso:: :py:func:`forcePolygonClockwise`

.. seealso:: :py:func:`forcePolygonCounterClockwise`

.. versionadded:: 3.36
%End


    QgsGeometry forceRHR() const;
%Docstring
Forces geometries to respect the Right-Hand-Rule, in which the area that is bounded by a polygon
is to the right of the boundary. In particular, the exterior ring is oriented in a clockwise direction
and the interior rings in a counter-clockwise direction.

.. warning::

   Due to the conflicting definitions of the right-hand-rule in general use, it is recommended
   to use the explicit :py:func:`~QgsGeometry.forcePolygonClockwise` or :py:func:`~QgsGeometry.forcePolygonCounterClockwise` methods instead.

.. seealso:: :py:func:`isPolygonClockwise`

.. seealso:: :py:func:`isPolygonCounterClockwise`

.. seealso:: :py:func:`forcePolygonClockwise`

.. seealso:: :py:func:`forcePolygonCounterClockwise`

.. versionadded:: 3.6
%End

    QgsGeometry forcePolygonClockwise() const;
%Docstring
Forces geometries to respect the exterior ring is clockwise, interior rings are counter-clockwise convention.

This convention is used primarily by ESRI software.

.. seealso:: :py:func:`isPolygonClockwise`

.. seealso:: :py:func:`isPolygonCounterClockwise`

.. seealso:: :py:func:`forcePolygonCounterClockwise`

.. versionadded:: 3.24
%End

    QgsGeometry forcePolygonCounterClockwise() const;
%Docstring
Forces geometries to respect the exterior ring is counter-clockwise, interior rings are clockwise convention.

This convention matches the OGC Simple Features specification.

.. seealso:: :py:func:`isPolygonClockwise`

.. seealso:: :py:func:`isPolygonCounterClockwise`

.. seealso:: :py:func:`forcePolygonClockwise`

.. versionadded:: 3.24
%End

    class Error
{
%Docstring(signature="appended")
A geometry error.
%End

%TypeHeaderCode
#include "qgsgeometry.h"
%End
      public:
        Error();

        explicit Error( const QString &m );

        Error( const QString &m, const QgsPointXY &p );
        QString what() const;
%Docstring
A human readable error message containing details about the error.
%End

        QgsPointXY where() const;
%Docstring
The coordinates at which the error is located and should be visualized.
%End

        bool hasWhere() const;
%Docstring
``True`` if the location available from :py:func:`where` is valid.
%End

        SIP_PYOBJECT __repr__();
%MethodCode
        QString str = QStringLiteral( "<QgsGeometry.Error: %1>" ).arg( sipCpp->what() );
        sipRes = PyUnicode_FromString( str.toUtf8().data() );
%End

        bool operator==( const QgsGeometry::Error &other ) const;

    };

    void validateGeometry( QVector<QgsGeometry::Error> &errors /Out/, Qgis::GeometryValidationEngine method = Qgis::GeometryValidationEngine::QgisInternal, Qgis::GeometryValidityFlags flags = Qgis::GeometryValidityFlags() ) const;
%Docstring
Validates geometry and produces a list of geometry errors.
The ``method`` argument dictates which validator to utilize.

The ``flags`` parameter indicates optional flags which control the type of validity checking performed.
%End

    void normalize();
%Docstring
Reorganizes the geometry into a normalized form (or "canonical" form).

Polygon rings will be rearranged so that their starting vertex is the lower left and ring orientation follows the
right hand rule, collections are ordered by geometry type, and other normalization techniques are applied. The
resultant geometry will be geometrically equivalent to the original geometry.

.. versionadded:: 3.20
%End

    static QgsGeometry unaryUnion( const QVector<QgsGeometry> &geometries, const QgsGeometryParameters &parameters = QgsGeometryParameters() );
%Docstring
Compute the unary union on a list of ``geometries``. May be faster than an iterative union on a set of geometries.
The returned geometry will be fully noded, i.e. a node will be created at every common intersection of the
input geometries. An empty geometry will be returned in the case of errors.

Since QGIS 3.28 the optional ``parameters`` argument can be used to specify parameters which
control the union results.
%End

    static QgsGeometry polygonize( const QVector<QgsGeometry> &geometries );
%Docstring
Creates a GeometryCollection geometry containing possible polygons formed from the constituent
linework of a set of ``geometries``. The input geometries must be fully noded (i.e. nodes exist
at every common intersection of the geometries). The easiest way to ensure this is to first
call :py:func:`~QgsGeometry.unaryUnion` on the set of input geometries and then pass the result to :py:func:`~QgsGeometry.polygonize`.
An empty geometry will be returned in the case of errors.
%End

    void convertToStraightSegment( double tolerance = M_PI / 180., QgsAbstractGeometry::SegmentationToleranceType toleranceType = QgsAbstractGeometry::MaximumAngle );
%Docstring
Converts the geometry to straight line segments, if it is a curved geometry type.

:param tolerance: segmentation tolerance
:param toleranceType: maximum segmentation angle or maximum difference between approximation and curve

.. seealso:: :py:func:`requiresConversionToStraightSegments`
%End

    bool requiresConversionToStraightSegments() const;
%Docstring
Returns ``True`` if the geometry is a curved geometry type which requires conversion to
display as straight line segments.

.. seealso:: :py:func:`convertToStraightSegment`
%End

    void mapToPixel( const QgsMapToPixel &mtp );
%Docstring
Transforms the geometry from map units to pixels in place.

:param mtp: map to pixel transform
%End

    void draw( QPainter &p ) const;
%Docstring
Draws the geometry onto a QPainter

:param p: destination QPainter
%End

    bool vertexIdFromVertexNr( int number, QgsVertexId &id /Out/ ) const;
%Docstring
Calculates the vertex ID from a vertex ``number``.

If a matching vertex was found, it will be stored in ``id``.

Returns ``True`` if vertex was found.

.. seealso:: :py:func:`vertexNrFromVertexId`
%End

    int vertexNrFromVertexId( QgsVertexId id ) const;
%Docstring
Returns the vertex number corresponding to a vertex ``id``.

The vertex numbers start at 0, so a return value of 0 corresponds
to the first vertex.

Returns -1 if a corresponding vertex could not be found.

.. seealso:: :py:func:`vertexIdFromVertexNr`
%End

    QString lastError() const /HoldGIL/;
%Docstring
Returns an error string referring to the last error encountered
either when this geometry was created or when an operation
was performed on the geometry.
%End



    static QgsGeometry fromQPointF( QPointF point ) /HoldGIL/;
%Docstring
Construct geometry from a QPointF

:param point: source QPointF
%End

    static QgsGeometry fromQPolygonF( const QPolygonF &polygon );
%Docstring
Construct geometry from a QPolygonF. If the polygon is closed than
the resultant geometry will be a polygon, if it is open than the
geometry will be a polyline.

:param polygon: source QPolygonF
%End

 static QgsPolylineXY createPolylineFromQPolygonF( const QPolygonF &polygon ) /Deprecated/;
%Docstring
Creates a :py:class:`QgsPolylineXY` from a QPolygonF.

:param polygon: source polygon

:return: :py:class:`QgsPolylineXY`

.. seealso:: :py:func:`createPolygonFromQPolygonF`

.. deprecated::
   use :py:func:`QgsGeometry.fromQPolygonF()` or :py:func:`QgsLineString.fromQPolygonF()` instead.
%End

 static QgsPolygonXY createPolygonFromQPolygonF( const QPolygonF &polygon ) /Deprecated/;
%Docstring
Creates a :py:class:`QgsPolygonXYfrom` a QPolygonF.

:param polygon: source polygon

:return: :py:class:`QgsPolygon`

.. seealso:: :py:func:`createPolylineFromQPolygonF`

.. deprecated::
   use :py:func:`QgsGeometry.fromQPolygonF()` or :py:func:`QgsLineString.fromQPolygonF()` instead.
%End


    static bool compare( PyObject *obj1, PyObject *obj2, double epsilon = 4 * DBL_EPSILON );
%Docstring
Compares two geometry objects for equality within a specified tolerance.
The objects can be of type :py:class:`QgsPolylineXY`, :py:class:`QgsPolygonXYor` :py:class:`QgsMultiPolygon`.
The 2 types should match.

:param p1: first geometry object
:param p2: second geometry object
:param epsilon: maximum difference for coordinates between the objects

:return: ``True`` if objects are

         - polylines and have the same number of points and all
           points are equal within the specified tolerance
         - polygons and have the same number of points and all
           points are equal within the specified tolerance
         - multipolygons and  have the same number of polygons, the polygons have the same number
           of rings, and each ring has the same number of points and all points are equal
           within the specified tolerance
%End
%MethodCode
    {
      sipRes = false;
      int state0;
      int state1;
      int sipIsErr = 0;

      if ( PyList_Check( a0 ) && PyList_Check( a1 ) &&
           PyList_GET_SIZE( a0 ) && PyList_GET_SIZE( a1 ) )
      {
        PyObject *o0 = PyList_GetItem( a0, 0 );
        PyObject *o1 = PyList_GetItem( a1, 0 );
        if ( o0 && o1 )
        {
          // compare polyline - polyline
          if ( sipCanConvertToType( o0, sipType_QgsPointXY, SIP_NOT_NONE ) &&
               sipCanConvertToType( o1, sipType_QgsPointXY, SIP_NOT_NONE ) &&
               sipCanConvertToType( a0, sipType_QVector_0100QgsPointXY, SIP_NOT_NONE ) &&
               sipCanConvertToType( a1, sipType_QVector_0100QgsPointXY, SIP_NOT_NONE ) )
          {
            QgsPolylineXY *p0;
            QgsPolylineXY *p1;
            p0 = reinterpret_cast<QgsPolylineXY *>( sipConvertToType( a0, sipType_QVector_0100QgsPointXY, 0, SIP_NOT_NONE, &state0, &sipIsErr ) );
            p1 = reinterpret_cast<QgsPolylineXY *>( sipConvertToType( a1, sipType_QVector_0100QgsPointXY, 0, SIP_NOT_NONE, &state1, &sipIsErr ) );
            if ( sipIsErr )
            {
              sipReleaseType( p0, sipType_QVector_0100QgsPointXY, state0 );
              sipReleaseType( p1, sipType_QVector_0100QgsPointXY, state1 );
            }
            else
            {
              sipRes = QgsGeometry::compare( *p0, *p1, a2 );
            }
          }
          else if ( PyList_Check( o0 ) && PyList_Check( o1 ) &&
                    PyList_GET_SIZE( o0 ) && PyList_GET_SIZE( o1 ) )
          {
            PyObject *oo0 = PyList_GetItem( o0, 0 );
            PyObject *oo1 = PyList_GetItem( o1, 0 );
            if ( oo0 && oo1 )
            {
              // compare polygon - polygon
              if ( sipCanConvertToType( oo0, sipType_QgsPointXY, SIP_NOT_NONE ) &&
                   sipCanConvertToType( oo1, sipType_QgsPointXY, SIP_NOT_NONE ) &&
                   sipCanConvertToType( a0, sipType_QVector_0600QVector_0100QgsPointXY, SIP_NOT_NONE ) &&
                   sipCanConvertToType( a1, sipType_QVector_0600QVector_0100QgsPointXY, SIP_NOT_NONE ) )
              {
                QgsPolygonXY *p0;
                QgsPolygonXY *p1;
                p0 = reinterpret_cast<QgsPolygonXY *>( sipConvertToType( a0, sipType_QVector_0600QVector_0100QgsPointXY, 0, SIP_NOT_NONE, &state0, &sipIsErr ) );
                p1 = reinterpret_cast<QgsPolygonXY *>( sipConvertToType( a1, sipType_QVector_0600QVector_0100QgsPointXY, 0, SIP_NOT_NONE, &state1, &sipIsErr ) );
                if ( sipIsErr )
                {
                  sipReleaseType( p0, sipType_QVector_0600QVector_0100QgsPointXY, state0 );
                  sipReleaseType( p1, sipType_QVector_0600QVector_0100QgsPointXY, state1 );
                }
                else
                {
                  sipRes = QgsGeometry::compare( *p0, *p1, a2 );
                }
              }
              else if ( PyList_Check( oo0 ) && PyList_Check( oo1 ) &&
                        PyList_GET_SIZE( oo0 ) && PyList_GET_SIZE( oo1 ) )
              {
                PyObject *ooo0 = PyList_GetItem( oo0, 0 );
                PyObject *ooo1 = PyList_GetItem( oo1, 0 );
                if ( ooo0 && ooo1 )
                {
                  // compare multipolygon - multipolygon
                  if ( sipCanConvertToType( ooo0, sipType_QgsPointXY, SIP_NOT_NONE ) &&
                       sipCanConvertToType( ooo1, sipType_QgsPointXY, SIP_NOT_NONE ) &&
                       sipCanConvertToType( a0, sipType_QVector_0600QVector_0600QVector_0100QgsPointXY, SIP_NOT_NONE ) &&
                       sipCanConvertToType( a1, sipType_QVector_0600QVector_0600QVector_0100QgsPointXY, SIP_NOT_NONE ) )
                  {
                    QgsMultiPolygonXY *p0;
                    QgsMultiPolygonXY *p1;
                    p0 = reinterpret_cast<QgsMultiPolygonXY *>( sipConvertToType( a0, sipType_QVector_0600QVector_0600QVector_0100QgsPointXY, 0, SIP_NOT_NONE, &state0, &sipIsErr ) );
                    p1 = reinterpret_cast<QgsMultiPolygonXY *>( sipConvertToType( a1, sipType_QVector_0600QVector_0600QVector_0100QgsPointXY, 0, SIP_NOT_NONE, &state1, &sipIsErr ) );
                    if ( sipIsErr )
                    {
                      sipReleaseType( p0, sipType_QVector_0600QVector_0600QVector_0100QgsPointXY, state0 );
                      sipReleaseType( p1, sipType_QVector_0600QVector_0600QVector_0100QgsPointXY, state1 );
                    }
                    else
                    {
                      sipRes = QgsGeometry::compare( *p0, *p1, a2 );
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
%End

    QgsGeometry smooth( unsigned int iterations = 1, double offset = 0.25,
                        double minimumDistance = -1.0, double maxAngle = 180.0 ) const;
%Docstring
Smooths a geometry by rounding off corners using the Chaikin algorithm. This operation
roughly doubles the number of vertices in a geometry.

If input geometries contain Z or M values, these will also be smoothed and the output
geometry will retain the same dimensionality as the input geometry.

:param iterations: number of smoothing iterations to run. More iterations results
                   in a smoother geometry
:param offset: fraction of line to create new vertices along, between 0 and 1.0,
               e.g., the default value of 0.25 will create new vertices 25% and 75% along each line segment
               of the geometry for each iteration. Smaller values result in "tighter" smoothing.
:param minimumDistance: minimum segment length to apply smoothing to
:param maxAngle: maximum angle at node (0-180) at which smoothing will be applied
%End

    static QgsGeometryEngine *createGeometryEngine( const QgsAbstractGeometry *geometry, double precision = 0.0 ) /Factory/;
%Docstring
Creates and returns a new geometry engine representing the specified ``geometry`` using ``precision`` on a grid. The ``precision`` argument was added in 3.36.

A geometry engine is a low-level representation of a :py:class:`QgsAbstractGeometry` object, optimised for use with external
geometry libraries such as GEOS.

:py:class:`QgsGeometryEngine` objects provide a mechanism for optimized evaluation of geometric algorithms, including spatial relationships
between geometries and operations such as buffers or clipping. :py:class:`QgsGeometryEngine` is recommended for use in any
performance critical code instead of directly using the equivalent QgsGeometry methods such as :py:func:`QgsGeometry.intersects()`.

Many methods available in the :py:class:`QgsGeometryEngine` class can benefit from pre-preparing geometries. For instance, whenever
a large number of spatial relationships will be tested (such as calling :py:func:`~QgsGeometry.intersects`, :py:func:`~QgsGeometry.within`, etc) then the
geometry should first be prepared by calling :py:func:`~QgsGeometry.prepareGeometry` before performing the tests.

Example
-------

.. code-block:: python

       # polygon_geometry contains a complex polygon, with many vertices
       polygon_geometry = QgsGeometry.fromWkt('Polygon((...))')

       # create a QgsGeometryEngine representation of the polygon
       polygon_geometry_engine = QgsGeometry.createGeometryEngine(polygon_geometry.constGet())

       # since we'll be performing many intersects tests, we can speed up these tests considerably
       # by first "preparing" the geometry engine
       polygon_geometry_engine.prepareGeometry()

       # now we are ready to quickly test intersection against many other objects
       for feature in my_layer.getFeatures():
           feature_geometry = feature.geometry()
           # test whether the feature's geometry intersects our original complex polygon
           if polygon_geometry_engine.intersects(feature_geometry.constGet()):
               print('feature intersects the polygon!')

:py:class:`QgsGeometryEngine` operations are backed by the GEOS library (https://trac.osgeo.org/geos/).
%End

    static void convertPointList( const QVector<QgsPointXY> &input, QgsPointSequence &output );
%Docstring
Upgrades a point list from :py:class:`QgsPointXY` to :py:class:`QgsPoint`

:param input: list of :py:class:`QgsPointXY` objects to be upgraded
:param output: destination for list of points converted to :py:class:`QgsPoint`
%End

    static void convertPointList( const QgsPointSequence &input, QVector<QgsPointXY> &output );
%Docstring
Downgrades a point list from :py:class:`QgsPoint` to :py:class:`QgsPointXY`

:param input: list of :py:class:`QgsPoint` objects to be downgraded
:param output: destination for list of points converted to :py:class:`QgsPointXY`
%End

    operator QVariant() const;

}; // class QgsGeometry



/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/geometry/qgsgeometry.h                                      *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.pl again   *
 ************************************************************************/
