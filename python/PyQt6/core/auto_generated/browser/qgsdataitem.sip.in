/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/browser/qgsdataitem.h                                       *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.py again   *
 ************************************************************************/








class QgsDataItem : QObject
{
%Docstring(signature="appended")
Base class for all items in the model.

Parent/children hierarchy is not based on QObject.
%End

%TypeHeaderCode
#include "qgsdataitem.h"
#include "qgslayeritem.h"
#include "qgsdirectoryitem.h"
#include "qgsfavoritesitem.h"
#include "qgszipitem.h"
#include "qgsdatacollectionitem.h"
#include "qgsprojectitem.h"
%End
%ConvertToSubClassCode
if ( qobject_cast<QgsLayerItem *>( sipCpp ) )
      sipType = sipType_QgsLayerItem;
    else if ( qobject_cast<QgsErrorItem *>( sipCpp ) )
      sipType = sipType_QgsErrorItem;
    else if ( qobject_cast<QgsDirectoryItem *>( sipCpp ) )
      sipType = sipType_QgsDirectoryItem;
    else if ( qobject_cast<QgsFavoritesItem *>( sipCpp ) )
      sipType = sipType_QgsFavoritesItem;
    else if ( qobject_cast<QgsZipItem *>( sipCpp ) )
      sipType = sipType_QgsZipItem;
    else if ( qobject_cast<QgsDataCollectionItem *>( sipCpp ) )
      sipType = sipType_QgsDataCollectionItem;
    else if ( qobject_cast<QgsProjectItem *>( sipCpp ) )
      sipType = sipType_QgsProjectItem;
    else
      sipType = 0;
%End
    SIP_PYOBJECT __repr__();
%MethodCode
    QString str = QStringLiteral( "<QgsDataItem: \"%1\" %2>" ).arg( sipCpp->name(), sipCpp->path() );
    sipRes = PyUnicode_FromString( str.toUtf8().constData() );
%End
%VirtualCatcherCode
    PyObject *sipResObj = sipCallMethod( 0, sipMethod, "" );
    // H = Convert a Python object to a mapped type instance.
    // 5 = 1 (disallows the conversion of Py_None to NULL) + 4 (returns a copy of the C/C++ instance)
    sipIsErr = !sipResObj || sipParseResult( 0, sipMethod, sipResObj, "H5", sipType_QVector_0101QgsDataItem, &sipRes ) < 0;
    if ( !sipIsErr )
    {
      for ( QgsDataItem *item : sipRes )
      {
        PyObject *pyItem = sipGetPyObject( item, sipType_QgsDataItem );
        if ( pyItem != NULL )
        {
          // pyItem is given an extra reference which is removed when the C++ instanceâ€™s destructor is called.
          sipTransferTo( pyItem, Py_None );
        }
      }
    }
    if ( sipResObj != NULL )
    {
      Py_DECREF( sipResObj );
    }
%End
  protected:
    virtual void populate( const QVector<QgsDataItem *> &children );

    virtual void refresh( const QVector<QgsDataItem *> &children );
%Docstring
Refresh the items from a specified list of child items.
%End

    bool deferredDelete() const;
%Docstring
Returns ``True`` if the item is scheduled to be deleted.

E.g. if :py:func:`~QgsDataItem.deleteLater` is called when item is in
Populating state (:py:func:`~QgsDataItem.createChildren` running in
another thread), the :py:func:`~QgsDataItem.deferredDelete` returns
``True`` and item will be deleted once Populating finished. Items with
slow :py:func:`~QgsDataItem.reateChildren` (for example network or
database based) may check during :py:func:`~QgsDataItem.createChildren`
if :py:func:`~QgsDataItem.deferredDelete` returns ``True`` and return
from :py:func:`~QgsDataItem.createChildren` immediately because result
will be useless.
%End



  public slots:

    virtual void deleteLater();
%Docstring
Safely delete the item:

- disconnects parent
- unsets parent (but does not remove itself)
- deletes all its descendants recursively
- waits until Populating state (:py:func:`~QgsDataItem.createChildren`
  in thread) finished without blocking main thread
- calls QObject.deleteLater()
%End

    virtual void populate( bool foreground = false );

    virtual void depopulate();
%Docstring
Remove children recursively and set as not populated. This is used when
refreshing collapsed items.
%End

    virtual void refresh();

    virtual void refreshConnections( const QString &providerKey = QString() );
%Docstring
Causes a data item provider to refresh all registered connections.

If ``providerKey`` is specified then only the matching provider will be
refreshed. Otherwise, all providers will be refreshed (which is
potentially very expensive!).
%End

    virtual void childrenCreated();

  signals:

    void beginInsertItems( QgsDataItem *parent, int first, int last );
%Docstring
Emitted before child items are added to this data item.

This signal *must* be followed by
:py:func:`~QgsDataItem.endInsertItems`.

:param parent: the parent item having children added, will always be
               this object
:param first: index of first child item to be added
:param last: index last child item, after the addition has occurred

.. seealso:: :py:func:`endInsertItems`
%End

    void endInsertItems();
%Docstring
Emitted after child items have been added to this data item.

This signal will always be preceded by
:py:func:`~QgsDataItem.beginInsertItems`.

.. seealso:: :py:func:`beginInsertItems`
%End

    void beginRemoveItems( QgsDataItem *parent, int first, int last );
%Docstring
Emitted before child items are removed from this data item.

This signal *must* be followed by
:py:func:`~QgsDataItem.endRemoveItems`.

:param parent: the parent item having children removed, will always be
               this object
:param first: index of first child item to be removed
:param last: index of the last child item to be removed

.. seealso:: :py:func:`endRemoveItems`
%End

    void endRemoveItems();
%Docstring
Emitted after child items have been removed from this data item.

This signal will always be preceded by
:py:func:`~QgsDataItem.beginRemoveItems`.

.. seealso:: :py:func:`beginRemoveItems`
%End

    void dataChanged( QgsDataItem *item );
%Docstring
Emitted when data changes for an ``item``.
%End

    void stateChanged( QgsDataItem *item, Qgis::BrowserItemState oldState );
%Docstring
Emitted when an item's state is changed.
%End

    void connectionsChanged( const QString &providerKey = QString() );
%Docstring
Emitted when the connections of the provider with the specified
``providerKey`` have changed.

This signal is normally forwarded to the app in order to refresh the
connection item in the provider dialogs and to refresh the connection
items in the other open browsers.
%End

  protected slots:

    void updateIcon();
%Docstring
Will request a repaint of this icon.
%End

};

class QgsErrorItem : QgsDataItem
{
%Docstring(signature="appended")
A browser item that can be used to report problems (e.g. network error).
%End

%TypeHeaderCode
#include "qgsdataitem.h"
%End
  public:
    QgsErrorItem( QgsDataItem *parent, const QString &error, const QString &path );

    SIP_PYOBJECT __repr__();
%MethodCode
    QString str = QStringLiteral( "<QgsErrorItem: \"%1\" %2>" ).arg( sipCpp->name(), sipCpp->path() );
    sipRes = PyUnicode_FromString( str.toUtf8().constData() );
%End
};

/************************************************************************
 * This file has been generated automatically from                      *
 *                                                                      *
 * src/core/browser/qgsdataitem.h                                       *
 *                                                                      *
 * Do not edit manually ! Edit header and run scripts/sipify.py again   *
 ************************************************************************/
