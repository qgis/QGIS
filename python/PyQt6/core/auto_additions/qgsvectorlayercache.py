# The following has been generated automatically from src/core/vector/qgsvectorlayercache.h
try:
    QgsVectorLayerCache.__attribute_docs__ = {'finished': 'When filling the cache, this signal gets emitted once the cache is fully\ninitialized.\n', 'cachedLayerDeleted': 'Is emitted when the cached layer is deleted. Is emitted when the cached\nlayers :py:func:`~QgsVectorLayerCache.layerDelete` signal is being\nemitted, but before the local reference to it has been set to ``None``.\nSo call to :py:func:`~QgsVectorLayerCache.layer` will still return a\nvalid pointer for cleanup purpose.\n', 'attributeValueChanged': 'Emitted when an attribute is changed. Is re-emitted after the layer\nitself emits this signal. You should connect to this signal, to be sure,\nto not get a cached value if querying the cache.\n', 'featureAdded': "Emitted when a new feature has been added to the layer and this cache.\nYou should connect to this signal instead of the layers', if you want to\nbe sure that this cache has updated information for the new feature\n\n:param fid: The featureid of the changed feature\n", 'invalidated': 'The cache has been invalidated and cleared. Note that when a cache is\ninvalidated the :py:func:`~QgsVectorLayerCache.fullCache` setting will\nbe cleared, and a full cache rebuild via setFullCache( ``True`` ) will\nneed to be performed.\n'}
    QgsVectorLayerCache.__signal_arguments__ = {'attributeValueChanged': ['fid: QgsFeatureId', 'field: int', 'value: object'], 'featureAdded': ['fid: QgsFeatureId']}
    QgsVectorLayerCache.__group__ = ['vector']
except (NameError, AttributeError):
    pass
