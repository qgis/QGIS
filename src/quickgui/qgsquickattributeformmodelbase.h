/***************************************************************************
 qgsquickfeaturemodelbase.h
  --------------------------------------
  Date                 : 16.8.2016
  Copyright            : (C) 2016 by Matthias Kuhn
  Email                : matthias@opengis.ch
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef QGSQUICKATTRIBUTEFORMMODELBASE_H
#define QGSQUICKATTRIBUTEFORMMODELBASE_H

/// @cond PRIVATE

//
//  W A R N I N G
//  -------------
//
// This file is not part of the QGIS API.  It exists purely as an
// implementation detail.  This header file may change from version to
// version without notice, or even be removed.
//

#include <QStandardItemModel>
#include <QStack>

#include "qgseditformconfig.h"
#include "qgsexpressioncontext.h"

#include "qgis_quick.h"
#include "qgsquickfeaturemodel.h"

/**
 * \ingroup quick
 * This is an internal (implementation) class used as the source model for QgsQuickAttributeFormModel.
 *
 * \sa QgsQuickAttributeFormModel
 *
 * \since QGIS 3.2
 */
class QgsQuickAttributeFormModelBase : public QStandardItemModel
{
    Q_OBJECT

    Q_PROPERTY( QgsQuickFeatureModel *featureModel READ featureModel WRITE setFeatureModel NOTIFY featureModelChanged )
    Q_PROPERTY( bool hasTabs READ hasTabs WRITE setHasTabs NOTIFY hasTabsChanged )
    Q_PROPERTY( bool constraintsValid READ constraintsValid NOTIFY constraintsValidChanged )

  public:
    explicit QgsQuickAttributeFormModelBase( QObject *parent = nullptr );
    ~QgsQuickAttributeFormModelBase() = default;

    QHash<int, QByteArray> roleNames() const override;

    bool setData( const QModelIndex &index, const QVariant &value, int role = Qt::EditRole ) override;

    QgsQuickFeatureModel *featureModel() const;
    void setFeatureModel( QgsQuickFeatureModel *featureModel );

    bool hasTabs() const;
    void setHasTabs( bool hasTabs );

    void save();

    void create();

    bool constraintsValid() const;

    QVariant attribute( const QString &name ) const;

  signals:
    void featureModelChanged();
    void hasTabsChanged();
    void featureChanged();
    void constraintsValidChanged();

  private slots:
    void onLayerChanged();
    void onFeatureChanged();

  private:

    /**
     * Generates a root container for autogenerated layouts, so we can just use the same
     * form logic to deal with them.
     */
    QgsAttributeEditorContainer *generateRootContainer() const;  //#spellok

    QgsAttributeEditorContainer *invisibleRootContainer() const;

    void updateAttributeValue( QStandardItem *item );

    void flatten( QgsAttributeEditorContainer *container, QStandardItem *parent, const QString &parentVisibilityExpressions, QVector<QStandardItem *> &items );

    void updateVisibility( int fieldIndex = -1 );

    void setConstraintsValid( bool constraintsValid );

    QgsQuickFeatureModel *mFeatureModel = nullptr;
    QgsVectorLayer *mLayer = nullptr;
    std::unique_ptr<QgsAttributeEditorContainer> mTemporaryContainer;
    bool mHasTabs;

    typedef QPair<QgsExpression, QVector<QStandardItem *> > VisibilityExpression;
    QList<VisibilityExpression> mVisibilityExpressions;
    QMap<QStandardItem *, QgsExpression> mConstraints;

    QgsExpressionContext mExpressionContext;
    bool mConstraintsValid;
};

/// @endcond

#endif // QGSQUICKATTRIBUTEFORMMODELBASE_H
