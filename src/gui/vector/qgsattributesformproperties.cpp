/***************************************************************************
    qgsattributesformproperties.cpp
    ---------------------
    begin                : August 2017
    copyright            : (C) 2017 by David Signer
    email                : david at opengis dot ch
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include "qgsattributesformproperties.h"

#include "qgsactionmanager.h"
#include "qgsaddtaborgroup.h"
#include "qgsapplication.h"
#include "qgsattributeformcontaineredit.h"
#include "qgsattributesforminitcode.h"
#include "qgsattributesformtreeviewindicatorprovider.h"
#include "qgsattributesformtreeviewitemdelegate.h"
#include "qgsattributetypedialog.h"
#include "qgsattributewidgetedit.h"
#include "qgscodeeditor.h"
#include "qgseditorwidgetregistry.h"
#include "qgsexpressioncontextutils.h"
#include "qgsfieldcombobox.h"
#include "qgsgui.h"
#include "qgssettingsregistrycore.h"
#include "qgsxmlutils.h"

#include "moc_qgsattributesformproperties.cpp"

#ifdef ENABLE_MODELTEST
#include "modeltest.h"
#endif

const QgsSettingsEntryBool *QgsAttributesFormProperties::settingShowAliases = new QgsSettingsEntryBool( u"show-aliases"_s, sTreeAttributesForm, false, u"Whether to show aliases (true) or names (false) in both the Available Widgets and the Form Layout panels."_s );

QgsAttributesFormProperties::QgsAttributesFormProperties( QgsVectorLayer *layer, QWidget *parent )
  : QWidget( parent )
  , mLayer( layer )
{
  if ( !layer )
    return;

  setupUi( this );

  mEditorLayoutComboBox->addItem( tr( "Autogenerate" ), QVariant::fromValue( Qgis::AttributeFormLayout::AutoGenerated ) );
  mEditorLayoutComboBox->addItem( tr( "Drag and Drop Designer" ), QVariant::fromValue( Qgis::AttributeFormLayout::DragAndDrop ) );
  mEditorLayoutComboBox->addItem( tr( "Provide ui-file" ), QVariant::fromValue( Qgis::AttributeFormLayout::UiFile ) );
  mShowAliasesButton->setChecked( settingShowAliases->value() );

  // available widgets tree
  QGridLayout *availableWidgetsWidgetLayout = new QGridLayout;
  mAvailableWidgetsView = new QgsAttributesAvailableWidgetsView( mLayer, this );
  availableWidgetsWidgetLayout->addWidget( mAvailableWidgetsView );
  availableWidgetsWidgetLayout->setContentsMargins( 0, 0, 0, 0 );
  mAvailableWidgetsWidget->setLayout( availableWidgetsWidgetLayout );
  mAvailableWidgetsView->setContextMenuPolicy( Qt::CustomContextMenu );

  // we need a custom item delegate in order to draw indicators
  mAvailableWidgetsView->setItemDelegate( new QgsAttributesFormTreeViewItemDelegate( mAvailableWidgetsView ) );
  mAvailableWidgetsView->setStyle( new QgsAttributesFormTreeViewProxyStyle( mAvailableWidgetsView ) );

  mAvailableWidgetsModel = new QgsAttributesAvailableWidgetsModel( mLayer, QgsProject().instance(), this );
  mAvailableWidgetsProxyModel = new QgsAttributesFormProxyModel( this );
  mAvailableWidgetsProxyModel->setAttributesFormSourceModel( mAvailableWidgetsModel );
  mAvailableWidgetsProxyModel->setRecursiveFilteringEnabled( true );
  mAvailableWidgetsView->setModel( mAvailableWidgetsProxyModel );

  mConstraintIndicatorProviderAvailableWidgets = new QgsFieldConstraintIndicatorProvider( mAvailableWidgetsView );     // gets parented to the available widgets view
  mDefaultValueIndicatorProviderAvailableWidgets = new QgsFieldDefaultValueIndicatorProvider( mAvailableWidgetsView ); // gets parented to the available widgets view

#ifdef ENABLE_MODELTEST
  new ModelTest( mAvailableWidgetsProxyModel, this );
#endif

  // form layout tree
  QGridLayout *formLayoutWidgetLayout = new QGridLayout;
  mFormLayoutView = new QgsAttributesFormLayoutView( mLayer, this );
  formLayoutWidgetLayout->addWidget( mFormLayoutView );
  formLayoutWidgetLayout->setContentsMargins( 0, 0, 0, 0 );
  mFormLayoutWidget->setLayout( formLayoutWidgetLayout );

  // we need a custom item delegate in order to draw indicators
  mFormLayoutView->setItemDelegate( new QgsAttributesFormTreeViewItemDelegate( mFormLayoutView ) );
  mFormLayoutView->setStyle( new QgsAttributesFormTreeViewProxyStyle( mFormLayoutView ) );

  mFormLayoutModel = new QgsAttributesFormLayoutModel( mLayer, QgsProject().instance(), this );
  mFormLayoutProxyModel = new QgsAttributesFormProxyModel( this );
  mFormLayoutProxyModel->setAttributesFormSourceModel( mFormLayoutModel );
  mFormLayoutProxyModel->setRecursiveFilteringEnabled( true );
  mFormLayoutView->setModel( mFormLayoutProxyModel );

  mConstraintIndicatorProviderFormLayout = new QgsFieldConstraintIndicatorProvider( mFormLayoutView );     // gets parented to the form layout view
  mDefaultValueIndicatorProviderFormLayout = new QgsFieldDefaultValueIndicatorProvider( mFormLayoutView ); // gets parented to the form layout view

#ifdef ENABLE_MODELTEST
  new ModelTest( mFormLayoutProxyModel, this );
#endif

  connect( mAvailableWidgetsView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &QgsAttributesFormProperties::onAttributeSelectionChanged );
  connect( mFormLayoutView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &QgsAttributesFormProperties::onFormLayoutSelectionChanged );

  connect( mAvailableWidgetsView, &QWidget::customContextMenuRequested, this, &QgsAttributesFormProperties::onContextMenuRequested );

  connect( mAddContainerButton, &QAbstractButton::clicked, this, &QgsAttributesFormProperties::addContainer );
  connect( mRemoveLayoutItemButton, &QAbstractButton::clicked, this, &QgsAttributesFormProperties::removeTabOrGroupButton );
  connect( mInvertSelectionButton, &QAbstractButton::clicked, this, &QgsAttributesFormProperties::onInvertSelectionButtonClicked );
  connect( mShowAliasesButton, &QAbstractButton::toggled, this, &QgsAttributesFormProperties::toggleShowAliases );
  connect( mEditorLayoutComboBox, static_cast<void ( QComboBox::* )( int )>( &QComboBox::currentIndexChanged ), this, &QgsAttributesFormProperties::mEditorLayoutComboBox_currentIndexChanged );
  connect( pbnSelectEditForm, &QToolButton::clicked, this, &QgsAttributesFormProperties::pbnSelectEditForm_clicked );
  connect( mTbInitCode, &QPushButton::clicked, this, &QgsAttributesFormProperties::mTbInitCode_clicked );

  connect( mSearchLineEdit, &QgsFilterLineEdit::textChanged, this, &QgsAttributesFormProperties::updateFilteredItems );

  connect( mLayer, &QgsVectorLayer::updatedFields, this, [this] {
    if ( !mBlockUpdates )
      updatedFields();
  } );

  // Context menu and children actions
  mAvailableWidgetsContextMenu = new QMenu( this );
  mActionCopyWidgetConfiguration = new QAction( tr( "Copy widget configuration" ), this );
  mActionPasteWidgetConfiguration = new QAction( tr( "Paste widget configuration" ), this );

  connect( mActionCopyWidgetConfiguration, &QAction::triggered, this, &QgsAttributesFormProperties::copyWidgetConfiguration );
  connect( mActionPasteWidgetConfiguration, &QAction::triggered, this, &QgsAttributesFormProperties::pasteWidgetConfiguration );

  mAvailableWidgetsContextMenu->addAction( mActionCopyWidgetConfiguration );
  mAvailableWidgetsContextMenu->addAction( mActionPasteWidgetConfiguration );

  mMessageBar = new QgsMessageBar();
  mMessageBar->setSizePolicy( QSizePolicy::Minimum, QSizePolicy::Fixed );
  gridLayout->addWidget( mMessageBar, 0, 0 );

  // Assign initial size to splitter widgets. By doing so, we can
  // show an eventual horizontal scrollbar in the right-hand side panel
  splitter->setSizes( { widget->minimumSizeHint().width(), 600 } );
}

void QgsAttributesFormProperties::init()
{
  initAvailableWidgetsView();
  initFormLayoutView();

  initLayoutConfig();
  initInitPython();
  initSuppressCombo();
}

void QgsAttributesFormProperties::initAvailableWidgetsView()
{
  mAvailableWidgetsView->setSortingEnabled( false );
  mAvailableWidgetsView->setSelectionBehavior( QAbstractItemView::SelectRows );
  mAvailableWidgetsView->setSelectionMode( QAbstractItemView::SelectionMode::ExtendedSelection );
  mAvailableWidgetsView->setAcceptDrops( false );
  mAvailableWidgetsView->setDragDropMode( QAbstractItemView::DragDropMode::DragOnly );

  mAvailableWidgetsModel->populate();
  mAvailableWidgetsModel->setShowAliases( settingShowAliases->value() );
  mAvailableWidgetsView->expandAll();
}

void QgsAttributesFormProperties::initFormLayoutView()
{
  // tabs and groups info
  mFormLayoutView->setSortingEnabled( false );
  mFormLayoutView->setSelectionBehavior( QAbstractItemView::SelectRows );
  mFormLayoutView->setSelectionMode( QAbstractItemView::SelectionMode::ExtendedSelection );
  mFormLayoutView->setAcceptDrops( true );
  mFormLayoutView->setDragDropMode( QAbstractItemView::DragDropMode::DragDrop );
  mFormLayoutView->setDefaultDropAction( Qt::MoveAction );

  mFormLayoutView->selectionModel()->clear();
  mFormLayoutModel->populate();
  mFormLayoutModel->setShowAliases( settingShowAliases->value() );
  mFormLayoutView->expandAll();
}


void QgsAttributesFormProperties::initSuppressCombo()
{
  if ( QgsSettingsRegistryCore::settingsDigitizingDisableEnterAttributeValuesDialog->value() )
  {
    mFormSuppressCmbBx->addItem( tr( "Hide Form on Add Feature (global settings)" ), QVariant::fromValue( Qgis::AttributeFormSuppression::Default ) );
  }
  else
  {
    mFormSuppressCmbBx->addItem( tr( "Show Form on Add Feature (global settings)" ), QVariant::fromValue( Qgis::AttributeFormSuppression::Default ) );
  }
  mFormSuppressCmbBx->addItem( tr( "Hide Form on Add Feature" ), QVariant::fromValue( Qgis::AttributeFormSuppression::On ) );
  mFormSuppressCmbBx->addItem( tr( "Show Form on Add Feature" ), QVariant::fromValue( Qgis::AttributeFormSuppression::Off ) );

  mFormSuppressCmbBx->setCurrentIndex( mFormSuppressCmbBx->findData( QVariant::fromValue( mLayer->editFormConfig().suppress() ) ) );
}

void QgsAttributesFormProperties::initAvailableWidgetsActions( const QList< QgsAction > actions )
{
  mAvailableWidgetsModel->populateLayerActions( actions );
}

QgsExpressionContext QgsAttributesFormProperties::createExpressionContext() const
{
  QgsExpressionContext context;
  context.appendScopes( QgsExpressionContextUtils::globalProjectLayerScopes( mLayer ) );
  return context;
}

void QgsAttributesFormProperties::initLayoutConfig()
{
  mEditorLayoutComboBox->setCurrentIndex( mEditorLayoutComboBox->findData( QVariant::fromValue( mLayer->editFormConfig().layout() ) ) );

  mEditorLayoutComboBox_currentIndexChanged( mEditorLayoutComboBox->currentIndex() );

  const QgsEditFormConfig cfg = mLayer->editFormConfig();
  mEditFormLineEdit->setText( cfg.uiForm() );
}

void QgsAttributesFormProperties::initInitPython()
{
  const QgsEditFormConfig cfg = mLayer->editFormConfig();

  mInitCodeSource = cfg.initCodeSource();
  mInitFunction = cfg.initFunction();
  mInitFilePath = cfg.initFilePath();
  mInitCode = cfg.initCode();

  if ( mInitCode.isEmpty() )
  {
    mInitCode.append( tr( "# -*- coding: utf-8 -*-\n\"\"\"\n"
                          "QGIS forms can have a Python function that is called when the form is\n"
                          "opened.\n"
                          "\n"
                          "Use this function to add extra logic to your forms.\n"
                          "\n"
                          "Enter the name of the function in the \"Python Init function\"\n"
                          "field.\n"
                          "An example follows:\n"
                          "\"\"\"\n"
                          "from qgis.PyQt.QtWidgets import QWidget\n\n"
                          "def my_form_open(dialog, layer, feature):\n"
                          "    geom = feature.geometry()\n"
                          "    control = dialog.findChild(QWidget, \"MyLineEdit\")\n" ) );
  }
}

void QgsAttributesFormProperties::loadAttributeTypeDialog()
{
  if ( mAvailableWidgetsView->selectionModel()->selectedRows( 0 ).count() != 1 )
    return;

  const QModelIndex index = mAvailableWidgetsView->firstSelectedIndex();

  const QgsAttributesFormData::FieldConfig cfg = mAvailableWidgetsModel->data( index, QgsAttributesFormModel::ItemFieldConfigRole ).value< QgsAttributesFormData::FieldConfig >();
  const QString fieldName = mAvailableWidgetsModel->data( index, QgsAttributesFormModel::ItemNameRole ).toString();
  const int fieldIndex = mLayer->fields().indexOf( fieldName );

  if ( fieldIndex < 0 )
    return;

  mAttributeTypeDialog = new QgsAttributeTypeDialog( mLayer, fieldIndex, mAttributeTypeFrame );

  loadAttributeTypeDialogFromConfiguration( cfg );

  mAttributeTypeDialog->layout()->setContentsMargins( 0, 0, 0, 0 );
  mAttributeTypeFrame->layout()->setContentsMargins( 0, 0, 0, 0 );

  mAttributeTypeFrame->layout()->addWidget( mAttributeTypeDialog );
}

void QgsAttributesFormProperties::loadAttributeTypeDialogFromConfiguration( const QgsAttributesFormData::FieldConfig &config )
{
  const QgsFieldConstraints constraints = config.mFieldConstraints;

  mAttributeTypeDialog->setAlias( config.mAlias );
  mAttributeTypeDialog->setDataDefinedProperties( config.mDataDefinedProperties );
  mAttributeTypeDialog->setComment( config.mComment );
  mAttributeTypeDialog->setFieldEditable( config.mEditable );
  mAttributeTypeDialog->setLabelOnTop( config.mLabelOnTop );
  mAttributeTypeDialog->setReuseLastValuePolicy( config.mReuseLastValuePolicy );
  mAttributeTypeDialog->setNotNull( constraints.constraints() & QgsFieldConstraints::ConstraintNotNull );
  mAttributeTypeDialog->setNotNullEnforced( constraints.constraintStrength( QgsFieldConstraints::ConstraintNotNull ) == QgsFieldConstraints::ConstraintStrengthHard );
  mAttributeTypeDialog->setUnique( constraints.constraints() & QgsFieldConstraints::ConstraintUnique );
  mAttributeTypeDialog->setUniqueEnforced( constraints.constraintStrength( QgsFieldConstraints::ConstraintUnique ) == QgsFieldConstraints::ConstraintStrengthHard );
  mAttributeTypeDialog->setSplitPolicy( config.mSplitPolicy );
  mAttributeTypeDialog->setDuplicatePolicy( config.mDuplicatePolicy );
  mAttributeTypeDialog->setMergePolicy( config.mMergePolicy );
  mAttributeTypeDialog->setDefaultValueExpression( config.mDefaultValueExpression );
  mAttributeTypeDialog->setApplyDefaultValueOnUpdate( config.mApplyDefaultValueOnUpdate );

  QgsFieldConstraints::Constraints providerConstraints = QgsFieldConstraints::Constraints();
  if ( constraints.constraintOrigin( QgsFieldConstraints::ConstraintNotNull ) == QgsFieldConstraints::ConstraintOriginProvider )
    providerConstraints |= QgsFieldConstraints::ConstraintNotNull;
  if ( constraints.constraintOrigin( QgsFieldConstraints::ConstraintUnique ) == QgsFieldConstraints::ConstraintOriginProvider )
    providerConstraints |= QgsFieldConstraints::ConstraintUnique;
  if ( constraints.constraintOrigin( QgsFieldConstraints::ConstraintExpression ) == QgsFieldConstraints::ConstraintOriginProvider )
    providerConstraints |= QgsFieldConstraints::ConstraintExpression;
  mAttributeTypeDialog->setProviderConstraints( providerConstraints );

  mAttributeTypeDialog->setConstraintExpression( constraints.constraintExpression() );
  mAttributeTypeDialog->setConstraintExpressionDescription( constraints.constraintDescription() );
  mAttributeTypeDialog->setConstraintExpressionEnforced( constraints.constraintStrength( QgsFieldConstraints::ConstraintExpression ) == QgsFieldConstraints::ConstraintStrengthHard );

  // Make sure the widget is refreshed, even if
  // the new widget type matches the current one
  mAttributeTypeDialog->setEditorWidgetConfig( config.mEditorWidgetConfig );
  mAttributeTypeDialog->setEditorWidgetType( config.mEditorWidgetType, true );
}

void QgsAttributesFormProperties::storeAttributeTypeDialog()
{
  if ( !mAttributeTypeDialog )
    return;

  if ( mAttributeTypeDialog->fieldIdx() < 0 || mAttributeTypeDialog->fieldIdx() >= mLayer->fields().count() )
    return;

  QgsAttributesFormData::FieldConfig cfg;

  cfg.mComment = mLayer->fields().at( mAttributeTypeDialog->fieldIdx() ).comment();
  cfg.mEditable = mAttributeTypeDialog->fieldEditable();
  cfg.mLabelOnTop = mAttributeTypeDialog->labelOnTop();
  cfg.mReuseLastValuePolicy = mAttributeTypeDialog->reuseLastValuePolicy();
  cfg.mAlias = mAttributeTypeDialog->alias();
  cfg.mDataDefinedProperties = mAttributeTypeDialog->dataDefinedProperties();

  QgsFieldConstraints constraints;
  if ( mAttributeTypeDialog->notNull() )
  {
    constraints.setConstraint( QgsFieldConstraints::ConstraintNotNull );
  }
  else if ( mAttributeTypeDialog->notNullFromProvider() )
  {
    constraints.setConstraint( QgsFieldConstraints::ConstraintNotNull, QgsFieldConstraints::ConstraintOriginProvider );
  }

  if ( mAttributeTypeDialog->unique() )
  {
    constraints.setConstraint( QgsFieldConstraints::ConstraintUnique );
  }
  else if ( mAttributeTypeDialog->uniqueFromProvider() )
  {
    constraints.setConstraint( QgsFieldConstraints::ConstraintUnique, QgsFieldConstraints::ConstraintOriginProvider );
  }

  if ( !mAttributeTypeDialog->constraintExpression().isEmpty() )
  {
    constraints.setConstraint( QgsFieldConstraints::ConstraintExpression );
  }

  constraints.setConstraintExpression( mAttributeTypeDialog->constraintExpression(), mAttributeTypeDialog->constraintExpressionDescription() );

  constraints.setConstraintStrength( QgsFieldConstraints::ConstraintNotNull, mAttributeTypeDialog->notNullEnforced() ? QgsFieldConstraints::ConstraintStrengthHard : QgsFieldConstraints::ConstraintStrengthSoft );
  constraints.setConstraintStrength( QgsFieldConstraints::ConstraintUnique, mAttributeTypeDialog->uniqueEnforced() ? QgsFieldConstraints::ConstraintStrengthHard : QgsFieldConstraints::ConstraintStrengthSoft );
  constraints.setConstraintStrength( QgsFieldConstraints::ConstraintExpression, mAttributeTypeDialog->constraintExpressionEnforced() ? QgsFieldConstraints::ConstraintStrengthHard : QgsFieldConstraints::ConstraintStrengthSoft );

  // The call to mLayer->setDefaultValueDefinition will possibly emit updatedFields
  // which will set mAttributeTypeDialog to nullptr so we need to store any value before calling it
  cfg.mFieldConstraints = constraints;
  cfg.mEditorWidgetType = mAttributeTypeDialog->editorWidgetType();
  cfg.mEditorWidgetConfig = mAttributeTypeDialog->editorWidgetConfig();
  cfg.mSplitPolicy = mAttributeTypeDialog->splitPolicy();
  cfg.mDuplicatePolicy = mAttributeTypeDialog->duplicatePolicy();
  cfg.mMergePolicy = mAttributeTypeDialog->mergePolicy();

  cfg.mApplyDefaultValueOnUpdate = mAttributeTypeDialog->applyDefaultValueOnUpdate();
  cfg.mDefaultValueExpression = mAttributeTypeDialog->defaultValueExpression();

  const int fieldIndex = mAttributeTypeDialog->fieldIdx();
  const QString fieldName = mLayer->fields().at( fieldIndex ).name();

  QModelIndex index = mAvailableWidgetsModel->fieldModelIndex( fieldName );
  if ( index.isValid() )
  {
    mAvailableWidgetsModel->setData( index, QVariant::fromValue<QgsAttributesFormData::FieldConfig>( cfg ), QgsAttributesFormModel::ItemFieldConfigRole );
    mAvailableWidgetsModel->setData( index, mAttributeTypeDialog->alias(), QgsAttributesFormModel::ItemDisplayRole );
  }

  // Save field config to each matching field item in Form Layout model
  mFormLayoutModel->updateFieldConfigForFieldItems( fieldName, cfg );

  // Save alias to each matching field item in Form Layout model
  mFormLayoutModel->updateAliasForFieldItems( fieldName, mAttributeTypeDialog->alias() );
}

void QgsAttributesFormProperties::storeAttributeWidgetEdit()
{
  if ( !mAttributeWidgetEdit )
    return;

  if ( mFormLayoutView->selectionModel()->selectedRows().count() != 1 )
    return;

  QModelIndex index = mFormLayoutView->firstSelectedIndex();
  storeAttributeWidgetEdit( index );
}

void QgsAttributesFormProperties::storeAttributeWidgetEdit( const QModelIndex &index )
{
  if ( !mAttributeWidgetEdit )
    return;

  if ( !index.isValid() )
    return;

  auto itemData = index.data( QgsAttributesFormLayoutModel::ItemDataRole ).value< QgsAttributesFormData::AttributeFormItemData >();
  mAttributeWidgetEdit->updateItemData( itemData );

  if ( index.data( QgsAttributesFormModel::ItemTypeRole ) == QgsAttributesFormData::Relation )
  {
    QgsAttributesFormData::RelationEditorConfiguration config = mAttributeWidgetEdit->updatedRelationConfiguration();
    itemData.setRelationEditorConfiguration( config );
    mFormLayoutModel->setData( index, config.label, QgsAttributesFormLayoutModel::ItemDisplayRole );
  }
  mFormLayoutModel->setData( index, itemData, QgsAttributesFormLayoutModel::ItemDataRole );
}

void QgsAttributesFormProperties::loadAttributeWidgetEdit()
{
  if ( mFormLayoutView->selectionModel()->selectedRows().count() != 1 )
    return;

  const QModelIndex currentIndex = mFormLayoutView->firstSelectedIndex();
  const QgsAttributesFormData::AttributeFormItemData itemData = currentIndex.data( QgsAttributesFormModel::ItemDataRole ).value< QgsAttributesFormData::AttributeFormItemData >();
  mAttributeWidgetEdit = new QgsAttributeWidgetEdit( itemData, this );
  if ( currentIndex.data( QgsAttributesFormModel::ItemTypeRole ) == QgsAttributesFormData::Relation )
  {
    mAttributeWidgetEdit->setRelationSpecificWidget( itemData.relationEditorConfiguration(), currentIndex.data( QgsAttributesFormModel::ItemIdRole ).toString() );
  }
  mAttributeTypeFrame->layout()->setContentsMargins( 0, 0, 0, 0 );
  mAttributeTypeFrame->layout()->addWidget( mAttributeWidgetEdit );
}

void QgsAttributesFormProperties::loadInfoWidget( const QString &infoText )
{
  mInfoTextWidget = new QLabel( infoText );
  mAttributeTypeFrame->layout()->setContentsMargins( 0, 0, 0, 0 );
  mAttributeTypeFrame->layout()->addWidget( mInfoTextWidget );
}

void QgsAttributesFormProperties::storeAttributeContainerEdit()
{
  if ( !mAttributeContainerEdit )
    return;

  if ( mFormLayoutView->selectionModel()->selectedRows().count() != 1 )
    return;

  const QModelIndex currentIndex = mFormLayoutView->firstSelectedIndex();
  storeAttributeContainerEdit( currentIndex );
}

void QgsAttributesFormProperties::storeAttributeContainerEdit( const QModelIndex &index )
{
  if ( !mAttributeContainerEdit )
    return;

  if ( !index.isValid() )
    return;

  auto itemData = index.data( QgsAttributesFormModel::ItemDataRole ).value< QgsAttributesFormData::AttributeFormItemData >();
  QString containerName;

  mAttributeContainerEdit->updateItemData( itemData, containerName );
  mFormLayoutModel->setData( index, itemData, QgsAttributesFormLayoutModel::ItemDataRole );
  mFormLayoutModel->setData( index, containerName, QgsAttributesFormLayoutModel::ItemNameRole );
}

void QgsAttributesFormProperties::loadAttributeContainerEdit()
{
  if ( mFormLayoutView->selectionModel()->selectedRows().count() != 1 )
    return;

  const QModelIndex currentIndex = mFormLayoutView->firstSelectedIndex();
  const QgsAttributesFormData::AttributeFormItemData itemData = currentIndex.data( QgsAttributesFormModel::ItemDataRole ).value< QgsAttributesFormData::AttributeFormItemData >();
  mAttributeContainerEdit = new QgsAttributeFormContainerEdit( itemData, mLayer, this );
  mAttributeContainerEdit->setTitle( currentIndex.data( QgsAttributesFormModel::ItemNameRole ).toString() );
  mAttributeContainerEdit->setUpContainerTypeComboBox( !currentIndex.parent().isValid(), itemData.containerType() );

  mAttributeContainerEdit->registerExpressionContextGenerator( this );
  mAttributeContainerEdit->layout()->setContentsMargins( 0, 0, 0, 0 );
  mAttributeTypeFrame->layout()->setContentsMargins( 0, 0, 0, 0 );
  mAttributeTypeFrame->layout()->addWidget( mAttributeContainerEdit );
}

void QgsAttributesFormProperties::onAttributeSelectionChanged( const QItemSelection &, const QItemSelection & )
{
  disconnect( mFormLayoutView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &QgsAttributesFormProperties::onFormLayoutSelectionChanged );

  QModelIndex index;
  if ( mFormLayoutView->selectionModel()->selectedRows( 0 ).count() == 1 )
  {
    // Go to the form layout view and store the single-selected index, as
    // it will be used to store its current settings before being deselected
    index = mFormLayoutView->firstSelectedIndex();
  }

  loadAttributeSpecificEditor( mAvailableWidgetsView, mFormLayoutView, index );
  connect( mFormLayoutView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &QgsAttributesFormProperties::onFormLayoutSelectionChanged );
}

void QgsAttributesFormProperties::onFormLayoutSelectionChanged( const QItemSelection &, const QItemSelection &deselected )
{
  // when the selection changes in the DnD layout, sync the main tree
  disconnect( mAvailableWidgetsView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &QgsAttributesFormProperties::onAttributeSelectionChanged );
  QModelIndex index;
  if ( deselected.indexes().count() == 1 )
  {
    index = mFormLayoutProxyModel->mapToSource( deselected.indexes().at( 0 ) );
  }
  else if ( deselected.indexes().count() == 0 && mFormLayoutView->selectionModel()->selectedIndexes().count() == 2 )
  {
    // There was 1 selected, it was not deselected, but instead a new item was added to selection
    index = mFormLayoutView->firstSelectedIndex();
  }

  loadAttributeSpecificEditor( mFormLayoutView, mAvailableWidgetsView, index );
  connect( mAvailableWidgetsView->selectionModel(), &QItemSelectionModel::selectionChanged, this, &QgsAttributesFormProperties::onAttributeSelectionChanged );
}

void QgsAttributesFormProperties::loadAttributeSpecificEditor( QgsAttributesFormBaseView *emitter, QgsAttributesFormBaseView *receiver, QModelIndex &deselectedFormLayoutIndex )
{
  const Qgis::AttributeFormLayout layout = mEditorLayoutComboBox->currentData().value<Qgis::AttributeFormLayout>();

  if ( layout == Qgis::AttributeFormLayout::DragAndDrop )
  {
    storeAttributeWidgetEdit( deselectedFormLayoutIndex );
    storeAttributeContainerEdit( deselectedFormLayoutIndex );
  }
  if ( mAttributeTypeDialog )
  {
    storeAttributeTypeDialog();
  }

  clearAttributeTypeFrame();

  if ( emitter->selectionModel()->selectedRows( 0 ).count() != 1 )
  {
    receiver->clearSelection();
  }
  else
  {
    const QModelIndex index = emitter->firstSelectedIndex();
    const auto indexType = static_cast< QgsAttributesFormData::AttributesFormItemType >( index.data( QgsAttributesFormModel::ItemTypeRole ).toInt() );
    switch ( indexType )
    {
      case QgsAttributesFormData::Relation:
      {
        receiver->selectFirstMatchingItem( QgsAttributesFormData::Relation, index.data( QgsAttributesFormModel::ItemIdRole ).toString() );
        if ( layout == Qgis::AttributeFormLayout::DragAndDrop )
        {
          loadAttributeWidgetEdit();
        }
        else
        {
          loadInfoWidget( tr( "This configuration is available in the Drag and Drop Designer" ) );
        }
        break;
      }
      case QgsAttributesFormData::Field:
      {
        receiver->selectFirstMatchingItem( QgsAttributesFormData::Field, index.data( QgsAttributesFormModel::ItemNameRole ).toString() );
        if ( layout == Qgis::AttributeFormLayout::DragAndDrop )
        {
          loadAttributeWidgetEdit();
        }
        loadAttributeTypeDialog();
        break;
      }
      case QgsAttributesFormData::Container:
      {
        receiver->clearSelection();
        loadAttributeContainerEdit();
        break;
      }
      case QgsAttributesFormData::Action:
      {
        receiver->selectFirstMatchingItem( QgsAttributesFormData::Action, index.data( QgsAttributesFormModel::ItemIdRole ).toString() );
        const QgsAction action { mLayer->actions()->action( index.data( QgsAttributesFormModel::ItemIdRole ).toString() ) };
        loadInfoWidget( action.html() );
        break;
      }
      case QgsAttributesFormData::QmlWidget:
      case QgsAttributesFormData::HtmlWidget:
      case QgsAttributesFormData::TextWidget:
      case QgsAttributesFormData::SpacerWidget:
      {
        if ( layout != Qgis::AttributeFormLayout::DragAndDrop )
        {
          loadInfoWidget( tr( "This configuration is available with double-click in the Drag and Drop Designer" ) );
        }
        else
        {
          loadInfoWidget( tr( "This configuration is available with double-click in the Form Layout panel" ) );
        }
        receiver->clearSelection();
        break;
      }
      case QgsAttributesFormData::WidgetType:
      {
        receiver->clearSelection();
        break;
      }
    }
  }
}

void QgsAttributesFormProperties::clearAttributeTypeFrame()
{
  if ( mAttributeWidgetEdit )
  {
    mAttributeTypeFrame->layout()->removeWidget( mAttributeWidgetEdit );
    mAttributeWidgetEdit->deleteLater();
    mAttributeWidgetEdit = nullptr;
  }
  if ( mAttributeTypeDialog )
  {
    mAttributeTypeFrame->layout()->removeWidget( mAttributeTypeDialog );
    mAttributeTypeDialog->deleteLater();
    mAttributeTypeDialog = nullptr;
  }
  if ( mAttributeContainerEdit )
  {
    mAttributeTypeFrame->layout()->removeWidget( mAttributeContainerEdit );
    mAttributeContainerEdit->deleteLater();
    mAttributeContainerEdit = nullptr;
  }
  if ( mInfoTextWidget )
  {
    mAttributeTypeFrame->layout()->removeWidget( mInfoTextWidget );
    mInfoTextWidget->deleteLater();
    mInfoTextWidget = nullptr;
  }
}

void QgsAttributesFormProperties::onInvertSelectionButtonClicked( bool checked )
{
  Q_UNUSED( checked )
  for ( int i = 0; i < mFormLayoutProxyModel->rowCount(); ++i )
  {
    QModelIndex index = mFormLayoutProxyModel->index( i, 0 );
    mFormLayoutView->selectionModel()->select( index, QItemSelectionModel::Toggle );
  }
}

void QgsAttributesFormProperties::toggleShowAliases( bool checked )
{
  settingShowAliases->setValue( checked );
  mAvailableWidgetsModel->setShowAliases( checked );
  mFormLayoutModel->setShowAliases( checked );
}

void QgsAttributesFormProperties::addContainer()
{
  QList<QgsAddAttributeFormContainerDialog::ContainerPair> existingContainerList = mFormLayoutModel->listOfContainers();

  QModelIndex currentItem;
  if ( mFormLayoutView->selectionModel()->selectedRows().count() > 0 )
    currentItem = mFormLayoutView->firstSelectedIndex();

  QgsAddAttributeFormContainerDialog dialog( mLayer, existingContainerList, currentItem, this );

  if ( !dialog.exec() )
    return;

  const QString name = dialog.name();
  QModelIndex parentContainerItem = dialog.parentContainerItem();

  mFormLayoutModel->addContainer( parentContainerItem, name, dialog.columnCount(), dialog.containerType() );
  if ( parentContainerItem.isValid() )
    mFormLayoutView->setExpanded( parentContainerItem, true );
}

void QgsAttributesFormProperties::removeTabOrGroupButton()
{
  // deleting an item may delete any number of nested child items -- so we delete
  // them one at a time and then see if there's any selection left
  while ( true )
  {
    const QModelIndexList items = mFormLayoutView->selectionModel()->selectedRows();
    if ( items.empty() )
      break;

    const QModelIndex item = mFormLayoutProxyModel->mapToSource( items.at( 0 ) );
    mFormLayoutModel->removeRow( item.row(), item.parent() );
  }
}

void QgsAttributesFormProperties::mEditorLayoutComboBox_currentIndexChanged( int )
{
  // Refresh the right-hand side panel: first, save selection to recover it later
  const QItemSelection selection = mAvailableWidgetsView->selectionModel()->selection();
  if ( selection.count() > 0 )
  {
    mAvailableWidgetsView->selectionModel()->clear();
  }

  if ( mFormLayoutView->selectionModel()->selectedRows().count() > 0 )
  {
    mFormLayoutView->selectionModel()->clear(); // Get rid of e.g., container selection
  }

  const Qgis::AttributeFormLayout layout = mEditorLayoutComboBox->currentData().value<Qgis::AttributeFormLayout>();
  switch ( layout )
  {
    case Qgis::AttributeFormLayout::AutoGenerated:
      mFormLayoutWidget->setVisible( false );
      mTreeViewHorizontalSpacer->changeSize( 0, 20, QSizePolicy::Fixed, QSizePolicy::Fixed );
      mUiFileFrame->setVisible( false );
      mAddContainerButton->setVisible( false );
      mRemoveLayoutItemButton->setVisible( false );
      mInvertSelectionButton->setVisible( false );

      setAvailableWidgetsIndicatorProvidersEnabled( true );
      setFormLayoutIndicatorProvidersEnabled( false );
      break;

    case Qgis::AttributeFormLayout::DragAndDrop:
      mFormLayoutWidget->setVisible( true );
      mTreeViewHorizontalSpacer->changeSize( 6, 20, QSizePolicy::Fixed, QSizePolicy::Fixed );
      mUiFileFrame->setVisible( false );
      mAddContainerButton->setVisible( true );
      mRemoveLayoutItemButton->setVisible( true );
      mInvertSelectionButton->setVisible( true );

      setAvailableWidgetsIndicatorProvidersEnabled( false );
      setFormLayoutIndicatorProvidersEnabled( true );
      break;

    case Qgis::AttributeFormLayout::UiFile:
      // ui file
      mFormLayoutWidget->setVisible( false );
      mTreeViewHorizontalSpacer->changeSize( 0, 20, QSizePolicy::Fixed, QSizePolicy::Fixed );
      mUiFileFrame->setVisible( true );
      mAddContainerButton->setVisible( false );
      mRemoveLayoutItemButton->setVisible( false );
      mInvertSelectionButton->setVisible( false );

      setAvailableWidgetsIndicatorProvidersEnabled( true );
      setFormLayoutIndicatorProvidersEnabled( false );
      break;
  }

  // Get the selection back so that we refresh the right-hand side panel
  if ( selection.count() > 0 )
  {
    mAvailableWidgetsView->selectionModel()->select( selection, QItemSelectionModel::Select );
  }
}

void QgsAttributesFormProperties::mTbInitCode_clicked()
{
  QgsAttributesFormInitCode attributesFormInitCode;

  attributesFormInitCode.setCodeSource( mInitCodeSource );
  attributesFormInitCode.setInitCode( mInitCode );
  attributesFormInitCode.setInitFilePath( mInitFilePath );
  attributesFormInitCode.setInitFunction( mInitFunction );

  if ( !attributesFormInitCode.exec() )
    return;

  mInitCodeSource = attributesFormInitCode.codeSource();
  mInitCode = attributesFormInitCode.initCode();
  mInitFilePath = attributesFormInitCode.initFilePath();
  mInitFunction = attributesFormInitCode.initFunction();
}

void QgsAttributesFormProperties::pbnSelectEditForm_clicked()
{
  QgsSettings myQSettings;
  const QString lastUsedDir = myQSettings.value( u"style/lastUIDir"_s, QDir::homePath() ).toString();
  const QString uifilename = QFileDialog::getOpenFileName( this, tr( "Select edit form" ), lastUsedDir, tr( "UI file" ) + " (*.ui)" );

  if ( uifilename.isNull() )
    return;

  const QFileInfo fi( uifilename );
  myQSettings.setValue( u"style/lastUIDir"_s, fi.path() );
  mEditFormLineEdit->setText( uifilename );
}

void QgsAttributesFormProperties::store()
{
  storeAttributeWidgetEdit();
  storeAttributeContainerEdit();
  storeAttributeTypeDialog();
}

void QgsAttributesFormProperties::apply()
{
  mBlockUpdates++;
  store();

  QgsEditFormConfig editFormConfig = mLayer->editFormConfig();

  const QModelIndex fieldContainer = mAvailableWidgetsModel->fieldContainer();
  QModelIndex index;

  for ( int i = 0; i < mAvailableWidgetsModel->rowCount( fieldContainer ); i++ )
  {
    index = mAvailableWidgetsModel->index( i, 0, fieldContainer );
    const QgsAttributesFormData::FieldConfig cfg = index.data( QgsAttributesFormModel::ItemFieldConfigRole ).value<QgsAttributesFormData::FieldConfig>();

    const QString fieldName = index.data( QgsAttributesFormModel::ItemNameRole ).toString();
    const int idx = mLayer->fields().indexOf( fieldName );

    //continue in case field does not exist anymore
    if ( idx < 0 )
      continue;

    editFormConfig.setReadOnly( idx, !cfg.mEditable );
    editFormConfig.setLabelOnTop( idx, cfg.mLabelOnTop );
    editFormConfig.setReuseLastValuePolicy( idx, cfg.mReuseLastValuePolicy );

    if ( cfg.mDataDefinedProperties.count() > 0 )
    {
      editFormConfig.setDataDefinedFieldProperties( fieldName, cfg.mDataDefinedProperties );
    }

    mLayer->setEditorWidgetSetup( idx, QgsEditorWidgetSetup( cfg.mEditorWidgetType, cfg.mEditorWidgetConfig ) );

    const QgsFieldConstraints constraints = cfg.mFieldConstraints;
    mLayer->setConstraintExpression( idx, constraints.constraintExpression(), constraints.constraintDescription() );
    if ( constraints.constraints() & QgsFieldConstraints::ConstraintNotNull )
    {
      mLayer->setFieldConstraint( idx, QgsFieldConstraints::ConstraintNotNull, constraints.constraintStrength( QgsFieldConstraints::ConstraintNotNull ) );
    }
    else
    {
      mLayer->removeFieldConstraint( idx, QgsFieldConstraints::ConstraintNotNull );
    }
    if ( constraints.constraints() & QgsFieldConstraints::ConstraintUnique )
    {
      mLayer->setFieldConstraint( idx, QgsFieldConstraints::ConstraintUnique, constraints.constraintStrength( QgsFieldConstraints::ConstraintUnique ) );
    }
    else
    {
      mLayer->removeFieldConstraint( idx, QgsFieldConstraints::ConstraintUnique );
    }
    if ( constraints.constraints() & QgsFieldConstraints::ConstraintExpression )
    {
      mLayer->setFieldConstraint( idx, QgsFieldConstraints::ConstraintExpression, constraints.constraintStrength( QgsFieldConstraints::ConstraintExpression ) );
    }
    else
    {
      mLayer->removeFieldConstraint( idx, QgsFieldConstraints::ConstraintExpression );
    }

    mLayer->setFieldAlias( idx, cfg.mAlias );
    mLayer->setFieldSplitPolicy( idx, cfg.mSplitPolicy );
    mLayer->setFieldDuplicatePolicy( idx, cfg.mDuplicatePolicy );
    mLayer->setFieldMergePolicy( idx, cfg.mMergePolicy );

    mLayer->setDefaultValueDefinition( idx, QgsDefaultValue( cfg.mDefaultValueExpression, cfg.mApplyDefaultValueOnUpdate ) );
  }

  // // tabs and groups
  editFormConfig.clearTabs();

  for ( int t = 0; t < mFormLayoutModel->rowCount(); t++ )
  {
    QModelIndex index = mFormLayoutModel->index( t, 0 );
    QgsAttributeEditorElement *editorElement { mFormLayoutModel->createAttributeEditorWidget( index, nullptr ) };
    if ( editorElement )
      editFormConfig.addTab( editorElement );
  }

  editFormConfig.setUiForm( mEditFormLineEdit->text() );

  editFormConfig.setLayout( mEditorLayoutComboBox->currentData().value<Qgis::AttributeFormLayout>() );

  editFormConfig.setInitCodeSource( mInitCodeSource );
  editFormConfig.setInitFunction( mInitFunction );
  editFormConfig.setInitFilePath( mInitFilePath );
  editFormConfig.setInitCode( mInitCode );

  editFormConfig.setSuppress( mFormSuppressCmbBx->currentData().value<Qgis::AttributeFormSuppression>() );

  // write the legacy config of relation widgets to support settings read by the API
  const QModelIndex relationContainer = mAvailableWidgetsModel->relationContainer();

  for ( int i = 0; i < mAvailableWidgetsModel->rowCount( relationContainer ); i++ )
  {
    const QModelIndex relationIndex = mAvailableWidgetsModel->index( i, 0, relationContainer );

    const QgsAttributesFormData::AttributeFormItemData itemData = relationIndex.data( QgsAttributesFormModel::ItemDataRole ).value<QgsAttributesFormData::AttributeFormItemData>();
    const auto indexType = static_cast< QgsAttributesFormData::AttributesFormItemType >( relationIndex.data( QgsAttributesFormModel::ItemTypeRole ).toInt() );
    const QString indexId = relationIndex.data( QgsAttributesFormModel::ItemIdRole ).toString();

    const QModelIndex layoutIndex = mFormLayoutModel->firstRecursiveMatchingModelIndex( indexType, indexId );
    if ( layoutIndex.isValid() )
    {
      QVariantMap config;

      const QgsAttributesFormData::AttributeFormItemData tabIndexData = layoutIndex.data( QgsAttributesFormModel::ItemDataRole ).value<QgsAttributesFormData::AttributeFormItemData>();
      config[u"nm-rel"_s] = tabIndexData.relationEditorConfiguration().nmRelationId;
      config[u"force-suppress-popup"_s] = tabIndexData.relationEditorConfiguration().forceSuppressFormPopup;

      editFormConfig.setWidgetConfig( indexId, config );
      break;
    }
  }

  mLayer->setEditFormConfig( editFormConfig );
  mBlockUpdates--;
}


void QgsAttributesFormProperties::updatedFields()
{
  // Store configuration to insure changes made are kept after refreshing the list
  QMap<QString, QgsAttributesFormData::FieldConfig> fieldConfigs;

  const QModelIndex fieldContainerBefore = mAvailableWidgetsModel->fieldContainer();
  QModelIndex index;

  for ( int i = 0; i < mAvailableWidgetsModel->rowCount( fieldContainerBefore ); i++ )
  {
    index = mAvailableWidgetsModel->index( i, 0, fieldContainerBefore );
    const QString fieldName = index.data( QgsAttributesFormModel::ItemNameRole ).toString();
    const QgsAttributesFormData::FieldConfig config = index.data( QgsAttributesFormModel::ItemFieldConfigRole ).value< QgsAttributesFormData::FieldConfig >();
    fieldConfigs[fieldName] = config;
  }

  initAvailableWidgetsView();

  const QModelIndex fieldContainerAfter = mAvailableWidgetsModel->fieldContainer();

  for ( int i = 0; i < mAvailableWidgetsModel->rowCount( fieldContainerAfter ); i++ )
  {
    index = mAvailableWidgetsModel->index( i, 0, fieldContainerAfter );
    const QString fieldName = index.data( QgsAttributesFormModel::ItemNameRole ).toString();

    if ( fieldConfigs.contains( fieldName ) )
    {
      mAvailableWidgetsModel->setData( index, fieldConfigs[fieldName], QgsAttributesFormModel::ItemFieldConfigRole );
      mAvailableWidgetsModel->setData( index, fieldConfigs[fieldName].mAlias, QgsAttributesFormModel::ItemDisplayRole );
    }
  }
}

void QgsAttributesFormProperties::updateFilteredItems( const QString &filterText )
{
  const int availableWidgetsPreviousSelectionCount = mAvailableWidgetsView->selectionModel()->selectedRows().count();
  const int formLayoutPreviousSelectionCount = mFormLayoutView->selectionModel()->selectedRows().count();

  static_cast< QgsAttributesAvailableWidgetsView *>( mAvailableWidgetsView )->setFilterText( filterText );
  mAvailableWidgetsView->expandAll();

  static_cast< QgsAttributesFormLayoutView *>( mFormLayoutView )->setFilterText( filterText );
  mFormLayoutView->expandAll();

  // If there was no previous selection leave as is, since
  // after a filter change no new selection may be added (only lost).
  if ( !( availableWidgetsPreviousSelectionCount == 0 && formLayoutPreviousSelectionCount == 0 ) )
  {
    const int selectedAvailableWidgetItemCount = mAvailableWidgetsView->selectionModel()->selectedRows().count();
    const int selectedFormLayoutItemCount = mFormLayoutView->selectionModel()->selectedRows().count();

    if ( selectedAvailableWidgetItemCount == 0 && selectedFormLayoutItemCount == 0 )
    {
      // Clear right-hand side panel since all selected items have been filtered out
      clearAttributeTypeFrame();
    }
  }
}

void QgsAttributesFormProperties::onContextMenuRequested( QPoint point )
{
  if ( mAvailableWidgetsView->selectionModel()->selectedRows().count() != 1 )
    return;

  QPoint globalPos = mAvailableWidgetsView->viewport()->mapToGlobal( point );

  const QModelIndex index = mAvailableWidgetsView->indexAt( point );
  const auto itemType = static_cast< QgsAttributesFormData::AttributesFormItemType >( index.data( QgsAttributesFormModel::ItemTypeRole ).toInt() );
  if ( itemType == QgsAttributesFormData::Field )
  {
    const QClipboard *clipboard = QApplication::clipboard();
    const QMimeData *mimeData = clipboard->mimeData();
    if ( !mimeData )
      return;

    const bool pasteEnabled = mimeData->hasFormat( u"application/x-qgsattributetabledesignerelementclipboard"_s );
    mActionPasteWidgetConfiguration->setEnabled( pasteEnabled );
    mAvailableWidgetsContextMenu->popup( globalPos );
  }
}

void QgsAttributesFormProperties::copyWidgetConfiguration()
{
  if ( mAvailableWidgetsView->selectionModel()->selectedRows().count() != 1 )
    return;

  const QModelIndex index = mAvailableWidgetsView->firstSelectedIndex();
  const auto itemType = static_cast< QgsAttributesFormData::AttributesFormItemType >( index.data( QgsAttributesFormModel::ItemTypeRole ).toInt() );

  if ( itemType != QgsAttributesFormData::Field )
    return;

  const QString fieldName = index.data( QgsAttributesFormModel::ItemNameRole ).toString();
  const int fieldIndex = mLayer->fields().indexOf( fieldName );

  if ( fieldIndex < 0 )
    return;

  const QgsField field = mLayer->fields().field( fieldIndex );

  // We'll copy everything but field aliases or comments
  QDomDocument doc;
  QDomElement documentElement = doc.createElement( u"FormWidgetClipboard"_s );
  documentElement.setAttribute( u"name"_s, field.name() );

  // Editor widget setup
  QgsEditorWidgetSetup widgetSetup = field.editorWidgetSetup();

  QDomElement editWidgetElement = doc.createElement( u"editWidget"_s );
  documentElement.appendChild( editWidgetElement );
  editWidgetElement.setAttribute( u"type"_s, widgetSetup.type() );
  QDomElement editWidgetConfigElement = doc.createElement( u"config"_s );

  editWidgetConfigElement.appendChild( QgsXmlUtils::writeVariant( widgetSetup.config(), doc ) );
  editWidgetElement.appendChild( editWidgetConfigElement );

  // Split policy
  QDomElement splitPolicyElement = doc.createElement( u"splitPolicy"_s );
  splitPolicyElement.setAttribute( u"policy"_s, qgsEnumValueToKey( field.splitPolicy() ) );
  documentElement.appendChild( splitPolicyElement );

  // Duplicate policy
  QDomElement duplicatePolicyElement = doc.createElement( u"duplicatePolicy"_s );
  duplicatePolicyElement.setAttribute( u"policy"_s, qgsEnumValueToKey( field.duplicatePolicy() ) );
  documentElement.appendChild( duplicatePolicyElement );

  // Merge policy
  QDomElement mergePolicyElement = doc.createElement( u"mergePolicy"_s );
  mergePolicyElement.setAttribute( u"policy"_s, qgsEnumValueToKey( field.mergePolicy() ) );
  documentElement.appendChild( mergePolicyElement );

  // Default expressions
  QDomElement defaultElem = doc.createElement( u"default"_s );
  defaultElem.setAttribute( u"expression"_s, field.defaultValueDefinition().expression() );
  defaultElem.setAttribute( u"applyOnUpdate"_s, field.defaultValueDefinition().applyOnUpdate() ? u"1"_s : u"0"_s );
  documentElement.appendChild( defaultElem );

  // Constraints
  QDomElement constraintElem = doc.createElement( u"constraint"_s );
  constraintElem.setAttribute( u"constraints"_s, field.constraints().constraints() );
  constraintElem.setAttribute( u"unique_strength"_s, field.constraints().constraintStrength( QgsFieldConstraints::ConstraintUnique ) );
  constraintElem.setAttribute( u"notnull_strength"_s, field.constraints().constraintStrength( QgsFieldConstraints::ConstraintNotNull ) );
  constraintElem.setAttribute( u"exp_strength"_s, field.constraints().constraintStrength( QgsFieldConstraints::ConstraintExpression ) );
  documentElement.appendChild( constraintElem );

  // Constraint expressions
  QDomElement constraintExpressionElem = doc.createElement( u"constraintExpression"_s );
  constraintExpressionElem.setAttribute( u"exp"_s, field.constraints().constraintExpression() );
  constraintExpressionElem.setAttribute( u"desc"_s, field.constraints().constraintDescription() );
  documentElement.appendChild( constraintExpressionElem );

  // Widget general settings
  if ( mAttributeTypeDialog )
  {
    QDomElement widgetGeneralSettingsElem = doc.createElement( u"widgetGeneralSettings"_s );
    widgetGeneralSettingsElem.setAttribute( u"editable"_s, mAttributeTypeDialog->fieldEditable() );
    widgetGeneralSettingsElem.setAttribute( u"label_on_top"_s, mAttributeTypeDialog->labelOnTop() );
    widgetGeneralSettingsElem.setAttribute( u"reuse_last_value_policy"_s, qgsEnumValueToKey( mAttributeTypeDialog->reuseLastValuePolicy() ) );
    documentElement.appendChild( widgetGeneralSettingsElem );
  }

  // Widget display section
  if ( mAttributeWidgetEdit )
  {
    // Go for the corresponding form layout item and extract its display settings
    if ( mFormLayoutView->selectionModel()->selectedRows().count() != 1 )
      return;

    const QModelIndex indexLayout = mFormLayoutView->firstSelectedIndex();
    const auto layoutData = indexLayout.data( QgsAttributesFormModel::ItemDataRole ).value< QgsAttributesFormData::AttributeFormItemData >();

    QDomElement displayElement = doc.createElement( u"widgetDisplay"_s );
    displayElement.setAttribute( u"showLabel"_s, layoutData.showLabel() );
    displayElement.setAttribute( u"horizontalStretch"_s, layoutData.horizontalStretch() );
    displayElement.setAttribute( u"verticalStretch"_s, layoutData.verticalStretch() );
    displayElement.appendChild( layoutData.labelStyle().writeXml( doc ) );
    documentElement.appendChild( displayElement );
  }

  doc.appendChild( documentElement );

  QMimeData *mimeData = new QMimeData;
  mimeData->setData( u"application/x-qgsattributetabledesignerelementclipboard"_s, doc.toByteArray() );
  QClipboard *clipboard = QApplication::clipboard();
  clipboard->setMimeData( mimeData );
}

void QgsAttributesFormProperties::pasteWidgetConfiguration()
{
  if ( mAvailableWidgetsView->selectionModel()->selectedRows().count() != 1 )
    return;

  QModelIndex index = mAvailableWidgetsView->firstSelectedIndex();

  const QString fieldName = index.data( QgsAttributesFormModel::ItemNameRole ).toString();
  const int fieldIndex = mLayer->fields().indexOf( fieldName );

  if ( fieldIndex < 0 )
    return;

  // Get base config from target item and ovewrite settings when possible
  auto config = index.data( QgsAttributesFormModel::ItemFieldConfigRole ).value< QgsAttributesFormData::FieldConfig >();

  QDomDocument doc;
  QClipboard *clipboard = QApplication::clipboard();
  const QMimeData *mimeData = clipboard->mimeData();
  if ( !mimeData )
    return;

  if ( doc.setContent( mimeData->data( u"application/x-qgsattributetabledesignerelementclipboard"_s ) ) )
  {
    QDomElement docElem = doc.documentElement();
    if ( docElem.tagName() != "FormWidgetClipboard"_L1 )
      return;

    // When pasting, the target item has already been selected and
    // has triggered attribute type dialog loading. Therefore, we'll
    // only overwrite GUI settings instead of destroying and recreating
    // the whole dialog.

    // Editor widget configuration
    const QDomElement fieldWidgetElement = docElem.firstChildElement( u"editWidget"_s );
    if ( !fieldWidgetElement.isNull() )
    {
      const QString widgetType = fieldWidgetElement.attribute( u"type"_s );

      // Only paste if source editor widget type is supported by target field
      const QgsEditorWidgetFactory *factory = QgsGui::editorWidgetRegistry()->factory( widgetType );
      if ( factory->supportsField( mLayer, fieldIndex ) )
      {
        const QDomElement configElement = fieldWidgetElement.firstChildElement( u"config"_s );
        if ( !configElement.isNull() )
        {
          const QDomElement optionsElem = configElement.childNodes().at( 0 ).toElement();
          QVariantMap optionsMap = QgsXmlUtils::readVariant( optionsElem ).toMap();
          QgsReadWriteContext context;
          // translate widget configuration strings
          if ( widgetType == "ValueRelation"_L1 )
          {
            optionsMap[u"Value"_s] = context.projectTranslator()->translate( u"project:layers:%1:fields:%2:valuerelationvalue"_s.arg( mLayer->id(), fieldName ), optionsMap[u"Value"_s].toString() );
          }
          if ( widgetType == "ValueMap"_L1 )
          {
            if ( optionsMap[u"map"_s].canConvert<QList<QVariant>>() )
            {
              QList<QVariant> translatedValueList;
              const QList<QVariant> valueList = optionsMap[u"map"_s].toList();
              for ( int i = 0, row = 0; i < valueList.count(); i++, row++ )
              {
                QMap<QString, QVariant> translatedValueMap;
                QString translatedKey = context.projectTranslator()->translate( u"project:layers:%1:fields:%2:valuemapdescriptions"_s.arg( mLayer->id(), fieldName ), valueList[i].toMap().constBegin().key() );
                translatedValueMap.insert( translatedKey, valueList[i].toMap().constBegin().value() );
                translatedValueList.append( translatedValueMap );
              }
              optionsMap.insert( u"map"_s, translatedValueList );
            }
          }
          config.mEditorWidgetType = widgetType;
          config.mEditorWidgetConfig = optionsMap;
        }
      }
      else
      {
        mMessageBar->pushMessage( QString(), tr( "Unable to paste widget configuration. The target field (%1) does not support the %2 widget type." ).arg( fieldName, widgetType ), Qgis::MessageLevel::Warning );
      }
    }

    // Split policy
    const QDomElement splitPolicyElement = docElem.firstChildElement( u"splitPolicy"_s );
    if ( !splitPolicyElement.isNull() )
    {
      const Qgis::FieldDomainSplitPolicy policy = qgsEnumKeyToValue( splitPolicyElement.attribute( u"policy"_s ), Qgis::FieldDomainSplitPolicy::Duplicate );
      config.mSplitPolicy = policy;
    }

    // Duplicate policy
    const QDomElement duplicatePolicyElement = docElem.firstChildElement( u"duplicatePolicy"_s );
    if ( !duplicatePolicyElement.isNull() )
    {
      const Qgis::FieldDuplicatePolicy policy = qgsEnumKeyToValue( duplicatePolicyElement.attribute( u"policy"_s ), Qgis::FieldDuplicatePolicy::Duplicate );
      config.mDuplicatePolicy = policy;
    }

    // Merge policy
    const QDomElement mergePolicyElement = docElem.firstChildElement( u"mergePolicy"_s );
    if ( !mergePolicyElement.isNull() )
    {
      const Qgis::FieldDomainMergePolicy policy = qgsEnumKeyToValue( mergePolicyElement.attribute( u"policy"_s ), Qgis::FieldDomainMergePolicy::DefaultValue );
      config.mMergePolicy = policy;
    }

    // Default expressions
    const QDomElement defaultElement = docElem.firstChildElement( u"default"_s );
    if ( !defaultElement.isNull() )
    {
      config.mDefaultValueExpression = defaultElement.attribute( u"expression"_s );
      config.mApplyDefaultValueOnUpdate = defaultElement.attribute( u"applyOnUpdate"_s ).toInt();
    }

    // Constraints
    // take target field constraints as a basis
    QgsFieldConstraints fieldConstraints = config.mFieldConstraints;
    const QDomElement constraintElement = docElem.firstChildElement( u"constraint"_s );
    if ( !constraintElement.isNull() )
    {
      const int intConstraints = constraintElement.attribute( u"constraints"_s, u"0"_s ).toInt();
      QgsFieldConstraints::Constraints constraints = static_cast< QgsFieldConstraints::Constraints >( intConstraints );

      // always keep provider constraints intact
      if ( fieldConstraints.constraintOrigin( QgsFieldConstraints::ConstraintNotNull ) != QgsFieldConstraints::ConstraintOriginProvider )
      {
        if ( constraints & QgsFieldConstraints::ConstraintNotNull )
          fieldConstraints.setConstraint( QgsFieldConstraints::ConstraintNotNull, QgsFieldConstraints::ConstraintOriginLayer );
        else
          fieldConstraints.removeConstraint( QgsFieldConstraints::ConstraintNotNull );
      }
      if ( fieldConstraints.constraintOrigin( QgsFieldConstraints::ConstraintUnique ) != QgsFieldConstraints::ConstraintOriginProvider )
      {
        if ( constraints & QgsFieldConstraints::ConstraintUnique )
          fieldConstraints.setConstraint( QgsFieldConstraints::ConstraintUnique, QgsFieldConstraints::ConstraintOriginLayer );
        else
          fieldConstraints.removeConstraint( QgsFieldConstraints::ConstraintUnique );
      }
      if ( fieldConstraints.constraintOrigin( QgsFieldConstraints::ConstraintExpression ) != QgsFieldConstraints::ConstraintOriginProvider )
      {
        if ( constraints & QgsFieldConstraints::ConstraintExpression )
          fieldConstraints.setConstraint( QgsFieldConstraints::ConstraintExpression, QgsFieldConstraints::ConstraintOriginLayer );
        else
          fieldConstraints.removeConstraint( QgsFieldConstraints::ConstraintExpression );
      }

      const int uniqueStrength = constraintElement.attribute( u"unique_strength"_s, u"1"_s ).toInt();
      const int notNullStrength = constraintElement.attribute( u"notnull_strength"_s, u"1"_s ).toInt();
      const int expStrength = constraintElement.attribute( u"exp_strength"_s, u"1"_s ).toInt();

      fieldConstraints.setConstraintStrength( QgsFieldConstraints::ConstraintUnique, static_cast< QgsFieldConstraints::ConstraintStrength >( uniqueStrength ) );
      fieldConstraints.setConstraintStrength( QgsFieldConstraints::ConstraintNotNull, static_cast< QgsFieldConstraints::ConstraintStrength >( notNullStrength ) );
      fieldConstraints.setConstraintStrength( QgsFieldConstraints::ConstraintExpression, static_cast< QgsFieldConstraints::ConstraintStrength >( expStrength ) );
    }

    // Constraint expressions
    // always keep provider constraints intact
    if ( fieldConstraints.constraintOrigin( QgsFieldConstraints::ConstraintExpression ) != QgsFieldConstraints::ConstraintOriginProvider )
    {
      const QDomElement constraintExpressionElement = docElem.firstChildElement( u"constraintExpression"_s );
      if ( !constraintExpressionElement.isNull() )
      {
        QString expression = constraintExpressionElement.attribute( u"exp"_s, QString() );
        QString description = constraintExpressionElement.attribute( u"desc"_s, QString() );
        fieldConstraints.setConstraintExpression( expression, description );
      }
    }
    config.mFieldConstraints = fieldConstraints;

    const QDomElement widgetGeneralSettingsElement = docElem.firstChildElement( u"widgetGeneralSettings"_s );
    if ( !widgetGeneralSettingsElement.isNull() )
    {
      const int editable = widgetGeneralSettingsElement.attribute( u"editable"_s, u"0"_s ).toInt();
      Qgis::AttributeFormReuseLastValuePolicy reusePolicy = Qgis::AttributeFormReuseLastValuePolicy::NotAllowed;
      if ( widgetGeneralSettingsElement.hasAttribute( u"reuse_last_values"_s ) )
      {
        reusePolicy = widgetGeneralSettingsElement.attribute( u"reuse_last_values"_s, u"0"_s ).toInt() == 1 ? Qgis::AttributeFormReuseLastValuePolicy::AllowedDefaultOn : Qgis::AttributeFormReuseLastValuePolicy::NotAllowed;
      }
      else
      {
        reusePolicy = qgsEnumKeyToValue( widgetGeneralSettingsElement.attribute( u"reuse_last_values"_s ), Qgis::AttributeFormReuseLastValuePolicy::NotAllowed );
      }
      const int labelOnTop = widgetGeneralSettingsElement.attribute( u"label_on_top"_s, u"0"_s ).toInt();

      config.mEditable = editable;
      config.mReuseLastValuePolicy = reusePolicy;
      config.mLabelOnTop = labelOnTop;
    }

    loadAttributeTypeDialogFromConfiguration( config );

    // Widget display section
    if ( mAttributeWidgetEdit )
    {
      const QDomElement displayElement = docElem.firstChildElement( u"widgetDisplay"_s );
      if ( !displayElement.isNull() )
      {
        const int showLabel = displayElement.attribute( u"showLabel"_s, u"0"_s ).toInt();
        const int horizontalStretch = displayElement.attribute( u"horizontalStretch"_s, u"0"_s ).toInt();
        const int verticalStretch = displayElement.attribute( u"verticalStretch"_s, u"0"_s ).toInt();
        QgsAttributeEditorElement::LabelStyle style;
        style.readXml( displayElement );

        // Update current GUI controls
        mAttributeWidgetEdit->setShowLabel( showLabel );
        mAttributeWidgetEdit->setHorizontalStretch( horizontalStretch );
        mAttributeWidgetEdit->setVerticalStretch( verticalStretch );
        mAttributeWidgetEdit->setLabelStyle( style );
      }
    }
  }
}

void QgsAttributesFormProperties::setAvailableWidgetsIndicatorProvidersEnabled( bool enabled )
{
  // Only enable if the provider is disabled and only disable if it's enabled
  if ( enabled && !mDefaultValueIndicatorProviderAvailableWidgets->isEnabled() )
  {
    connect( mAvailableWidgetsModel, &QgsAttributesFormModel::fieldConfigDataChanged, mDefaultValueIndicatorProviderAvailableWidgets, &QgsFieldDefaultValueIndicatorProvider::updateItemIndicator );
    mDefaultValueIndicatorProviderAvailableWidgets->setEnabled( enabled );
  }
  else if ( !enabled && mDefaultValueIndicatorProviderAvailableWidgets->isEnabled() )
  {
    disconnect( mAvailableWidgetsModel, &QgsAttributesFormModel::fieldConfigDataChanged, mDefaultValueIndicatorProviderAvailableWidgets, &QgsFieldDefaultValueIndicatorProvider::updateItemIndicator );
    mDefaultValueIndicatorProviderAvailableWidgets->setEnabled( enabled );
  }

  if ( enabled && !mConstraintIndicatorProviderAvailableWidgets->isEnabled() )
  {
    connect( mAvailableWidgetsModel, &QgsAttributesFormModel::fieldConfigDataChanged, mConstraintIndicatorProviderAvailableWidgets, &QgsFieldConstraintIndicatorProvider::updateItemIndicator );
    mConstraintIndicatorProviderAvailableWidgets->setEnabled( enabled );
  }
  else if ( !enabled && mConstraintIndicatorProviderAvailableWidgets->isEnabled() )
  {
    disconnect( mAvailableWidgetsModel, &QgsAttributesFormModel::fieldConfigDataChanged, mConstraintIndicatorProviderAvailableWidgets, &QgsFieldConstraintIndicatorProvider::updateItemIndicator );
    mConstraintIndicatorProviderAvailableWidgets->setEnabled( enabled );
  }
}

void QgsAttributesFormProperties::setFormLayoutIndicatorProvidersEnabled( bool enabled )
{
  // Only enable if the provider is disabled and only disable if it's enabled
  if ( enabled && !mDefaultValueIndicatorProviderFormLayout->isEnabled() )
  {
    connect( mFormLayoutModel, &QgsAttributesFormModel::fieldConfigDataChanged, mDefaultValueIndicatorProviderFormLayout, &QgsFieldDefaultValueIndicatorProvider::updateItemIndicator );
    mDefaultValueIndicatorProviderFormLayout->setEnabled( enabled );
  }
  else if ( !enabled && mDefaultValueIndicatorProviderFormLayout->isEnabled() )
  {
    disconnect( mFormLayoutModel, &QgsAttributesFormModel::fieldConfigDataChanged, mDefaultValueIndicatorProviderFormLayout, &QgsFieldDefaultValueIndicatorProvider::updateItemIndicator );
    mDefaultValueIndicatorProviderFormLayout->setEnabled( enabled );
  }

  if ( enabled && !mConstraintIndicatorProviderFormLayout->isEnabled() )
  {
    connect( mFormLayoutModel, &QgsAttributesFormModel::fieldConfigDataChanged, mConstraintIndicatorProviderFormLayout, &QgsFieldConstraintIndicatorProvider::updateItemIndicator );
    mConstraintIndicatorProviderFormLayout->setEnabled( enabled );
  }
  else if ( !enabled && mConstraintIndicatorProviderFormLayout->isEnabled() )
  {
    disconnect( mFormLayoutModel, &QgsAttributesFormModel::fieldConfigDataChanged, mConstraintIndicatorProviderFormLayout, &QgsFieldConstraintIndicatorProvider::updateItemIndicator );
    mConstraintIndicatorProviderFormLayout->setEnabled( enabled );
  }
}
